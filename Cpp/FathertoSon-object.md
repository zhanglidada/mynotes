[[c]]++之父类指针指向子类对象
1 没有虚函数的继承
　　<font color=#6c365>如果以一个基础类指针指向一个派生类对象，那么经由该指针只能访问基础类定义的函数**（静态绑定）。**</font>
　　<font color=#34562>如果以一个派生类类指针指向一个基础类对象，必须先做强制转型动作（explicit cast），这种做法很危险，也不符合生活习惯，在程序设计上也会给程序员带来困扰。（一般不会这么去使用）</font>
　　<font color=#12345>如果基础类和派生类类定义了相同名称的成员函数，**那么通过对象指针调用成员函数时，到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。**（指针类型是谁就调用
　　谁）</font>
**注：需要说明一下为何基础类可以指向派生类对象，而派生类不去指向父类对象。**
　　通常来说，子类总是含有一些父类没有的成员变量，或者方法函数，而子类肯定含有父类所有的成员变量和方法函数。所以用父类指针指向子类时，没有问题，因为父类有的，子类都有，不会出现非法
　　访问问题。
　　但是如果用子类指针指向父类的话，一旦访问子类特有的方法函数或者成员变量，就会出现非法，因为被子类指针指向的由父类创建的对象，根本没有要访问的那些内容，那些是子类特有的，只有用
　　子类初始化对象时才会有。
2 包含虚函数的继承
　　有虚函数的继承，那么父类指针指向子类对象就是我们常见的多态实现，也就是动态绑定。
　　**虚拟函数就是为了对“如果你以一个基础类指针指向一个衍生类对象，那么通过该指针，你只能访问基础类定义的成员函数”这条规则反其道而行之的设计。**
　　当然这里还包括纯虚拟函数，<font color=red>只要是拥有纯虚拟函数的类，就是抽象类，它们是不能够被实例化的（只能被继承）</font>。如果一个继承类没有改写父类中的纯虚函数，那么他也是抽象类，也不能被实例化。**抽象类不能被实例化，不过我们可以拥有指向抽象类的指针，以便于操纵各个衍生类。**

	[[include]]<iostream>
	using namespace std;
	class Base{
	public:
	    virtual void foo(){
		cout<<"Base's foo()"<<endl;
		bar();
	    }
	    virtual void bar(){
		cout<<"Base's bar()"<<endl;
	    }
	};
	class Derived:public Base{
	public:
	    virtual void foo(){
		cout<<"Derived's foo()"<<endl;
		Base::foo();//子类的对象这里调用了父类的方法
	    }
	    virtual void bar(){
		cout<<"Derived's bar()"<<endl;
	    }
	};
	int main(){
	    Derived Dobj;//定义一个子类的对象
	    Base *ptr = &Dobj;//父类的对象指针指向子类对象
	    cout<<"ptr->foo()方法输出的结果："<<endl;
	    ptr->foo();//这里ptr是父类的指针
	    cout<<endl;
	    //Base Bobj = *ptr;//转换为子类的对象
	    Base Bobj = Dobj;//这里因为完全就是父类的对象，虽然初始化的时候是用子类对象对其进行初始化
	    cout<<"Bobj.foo()方法输出的结果："<<endl;
	    Bobj.foo();
	    return 0;
	}
输出结果：

	ptr->foo()方法输出的结果：
	Derived's foo()    //因为父类指针被指向子类对象，由于虚函数的使用，即满足多态性，先使用了子类的方法
	Base's foo()        //子类的foo函数中指定了调用父类的foo函数
	Derived's bar()   //虽然调用的是这个函数:Base::foo(); 但隐式传入的还Dobj的地址,所以当在父类虚函数foo中再次调用bar(); (此时并没有指明调用父类还是子类的bar函数) 调用时还是会调用Derived的虚函数, 
	//与虚函数指针有关

	Bobj.foo()方法输出的结果：
	//由于Bobj不是一个指针，它完全就是一个父类的对象，与多态完全没有关系
	Base's foo()
	Base's bar()


3.总结：
　　<font color=#336666>当定义一个指向子类实例的父类指针的时候，内存中实例化了子类</font>，由于子类继承了父类,因此内存中的子类里包含父类的所有成员。但由于声明的是父类指针，因此该指针不能够访问子类的成员，而只能
　　访问父类的成员。然而在父类里可以声明纯虚函数和定义虚函数，使用父类指针访问虚函数或纯虚函数的时候，访问到的是子类里重写的函数。当然，对于虚函数，如果子类里没有对其重写的话，仍然
　　访问到父类里定义的虚函数。**可见虚函数和纯虚函数的却别仅仅在于：<font color=#235675>纯虚函数没有定义,只有声明.</font>**
example:
	
	class Father
	{
	public:
	　　virtual void func_1(){}　　  //虚函数
	　　virtual void func_2();　　     //纯函数
	}
	class Child
	{
	public:
	　　void func_1();　　　　//可重写，也可不，重写格式可以和父类不同
	　　void func_2();　　　　//必须重写，而且格式必须和父类保持一致
	}
