[[C/C]]++ define用法详解
![5](/assets/5.png)
##1.预处理代码：
预处理代码，即在代码编译之前就被提前处理，这在C语言中，是一个非常强大的工具。利用预处理代码，可以重新定义代码的一部分，使得代码更适合自己的风格。预处理代码均由一个井号(#)开头。
###define总览：
c语言中用到很多宏定义 ，为了头文件被重复使用，常常用到`#ifndef  [[define]] [[endif]]`,`#ifdef  [[endif]]`等条件编译

**宏不是语句，结尾不用加“；”，否则会被替换进代码中**

‘#’表示这是一条预处理指令

如果写宏不止一行，则在结尾加反斜杠 '/' 使多行能连接上，但第二行要对齐，否则空格也会作为替换文本的一部分

##2.\#define用法：
###1.无参宏定义
1）无参宏的宏名后不带参数，只是简单的文本替换。
2）其定义的一般形式为：`#define  标识符  字符串`
  其中的“#”表示这是一条预处理命令。凡是以“#”开头的均为预处理命令。“define”为宏定义命令。“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。

例如：`#define MAXNUM 99999`  这样MAXNUM就被简单的定义为99999。

###2.有参宏定义
1）有参宏定义即带参数的宏定义，宏名中不能有空格，宏名与形参表之间也不能有空格，而形参表中形参之间可以有空格。
2）C++语言允许宏带有参数。在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。 对带参数的宏，在调用中不仅要宏展开，而且要用实参去代换形参。

带参宏定义的一般形式为：`#define  宏名(形参表)  字符串`

在字符串中含有各个形参。在使用时调用带参宏调用的一般形式为：宏名(实参表)；
例如：
```
[[define]] add(x, y)  (x + y)
int main()
{
    cout << "1 plus 1 is " << add(1, 1.5) << ".\n";
    //输出“1 plus 1 is 2.5.”
    system("pause");
    return(0);
}
```
这个“函数”定义了加法，但是该“函数”没有类型检查，有点类似模板，但没有模板安全，可以看做一个简单的模板。
**注意：**该“函数”定义为（a + b），在这里加括号的原因是，**宏定义只是在预处理阶段做了简单的字符串替换**，如果单纯的替换为a + b时，当你使用5 * add（2， 3）时，被替换为5 * 2 + 3，值为13，而非5 * （2 + 3），值为25。

3）有参宏与函数的区别:
在定义#define add(x, y)的时候，**有参宏中的形参不分配内存单元，不做类型定义，只是简单的文本替换**，而函数int add(int x,int y)中形参x和y是局部变量，会在栈区分配内存单元，所以要做类型定义，**而且实参与形参之间是值传递。而宏只是符号代换，不存在值传递。**

4）宏定义也可以定义表达式或者多个语句：
```
[[include]]<stdio.h>
[[define]] AB(a,b) a=i+5;b=j+3;   //宏定义多个语句
int main(){
	int i=3,j=5;
	int m=0,n=0;
	AB(m,n);       //宏替换后为m=i+5,n=j+3;
	printf("m=%d,n=%d",m,n);
	return 0;
}
// 输出结果：m=8,n=8
```

###3.宏定义中的特殊操作
在#define中的特殊操作符有`#`，`##`,`…`和`__VA_ARGS__`
1）"#"
假如**希望在字符串中包含宏参数**，ANSI C允许这样作 : 在类函数宏的替换部分，**"#"符号用作一个预处理运算符，它可以把语言符号转化程字符串。**

例如，如果`x`是一个宏参量，那么`#x`可以把参数名转化成相应的字符串。该过程称为字符串化。例如：
```
[[incldue]] <stdio.h>
[[define]] PSQR(x) printf("the square of" [[x]] "is %d.\n",(x)*(x))
int main(void)
{
    int y =4;
    PSQR(y);
    //输出：the square of y is 16.
    PSQR(2+4);
    //输出：the square of 2+4 is 36.
    return 0;
}
```
2）"##"
"##"运算符可以用于类函数宏的替换部分。另外，"##"还可以用于类对象宏的替换部分。**##运算符把*两个语言符号*组合成*单个语言符号*。**
例如：
```
[[include]]<stdio.h>
[[define]] XNAME(n) x##n //x##n被组成单个语言符号xn
[[define]] PXN(n) printf("x"#n" = %d\n",x##n)
int main(){
	int i=6;
	int XNAME(i) = 12;//定义一个变量xi并赋值
	PXN(i);//输出变量xi的值
	return 0;
}
// 输出结果为：x6 = 12
```
(3)可变参数宏 "…"和"__VA_ARGS__"
__VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。
实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。这样预定义宏__VA_ARGS__就可以被用在替换部分中，替换省略号所代表的字符串。
例如：

	[[define]] PR(...) printf(__VA_ARGS__)
	int main()
	{
	    int wt=1,sp=2;
	    PR("hello\n");
	    //输出：hello
	    PR("weight = %d, shipping = %d",wt,sp);
	    //输出：weight = 1, shipping = 2
	    return 0;
	}
省略号只能代替最后面的宏参数。
\#define W(x,…,y)错误！
**但是支持#define W(x, …)，此时传入的参数个数必须能够匹配。**
再介绍几个系统的宏：

	1) __VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。
	宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的”,”去掉的作用,否则会编译出错, 你可以试试。
	2) __FILE__ 宏在预编译时会替换成当前的源文件名
	3) __LINE__宏在预编译时会替换成当前的行号
	4) __FUNCTION__宏在预编译时会替换成当前的函数名称

###4.宏定义中的多行定义
这种方法经常使用：

	[[define]] MACRO(arg1, arg2) do { \
	/* declarations */ \
	stmt1; \
	stmt2; \
	/* ... */ \
	} while(0)
	/* (no trailing ; ) */

记得要在每一个换行的时候加上一个”\”，而且后面紧跟回车键，中间不能有其他空格或者字符

###5.宏定义中的条件编译
1).在大规模的开发过程中，特别是跨平台和系统的软件里，**define最重要的功能是条件编译。**

	[[ifdef]] WINDOWS
	......
	(#else)
	......
	[[endif]]

	[[ifdef]] LINUX
	......
	(#else)
	......
	[[endif]]
可以在编译的时候通过#define设置编译环境。
2).#if的使用说明
\#if的后面接的是表达式

	[[if]] (MAX==10)||(MAX==20)
	 code...
	[[endif]]
它的作用是：如果(MAX==10)||(MAX==20)成立，那么编译器就会把其中的#if 与 [[endif之间的代码编译进去]]<font color=red>（注意：是编译进去，不是执行！！）</font>

3).#if defined的使用:
\#if后面接的是一个宏。

	[[if]] defined (x)
	    ...code...
	[[endif]]
这个#if defined它不管里面的“x”的逻辑是“真”还是“假”,它只管这个程序的前面的宏定义里面有没有定义“x”这个宏，如果定义了x这个宏，那么，编译器会编译中间的…code…否则直接忽视中间的…code…代码。

4).另外 [[if]] defined(x)也可以取反，也就用 [[if]] !defined(x)

	[[if]] !defined (x)
	    ...code...
	[[endif]]
这里，用法刚好和上面相反。即只要上面没有定义宏x，那么编译...code...这些代码，否则忽略。

5).#ifdef的使用:
\#ifdef的使用和#if defined()的用法一致
\#ifndef又和#if !defined()的用法一致。

<font color=darkblue>最后强调两点：
第一：这几个宏定义只是决定代码块是否被编译！
第二：别忘了#endif</font>
###6.如何取消宏

	//定义宏
	[[define]] [MacroName]  [MacroValue]
	//取消宏
	[[undef]] [MacroName]

###7.常用的宏定义使用：
1).防止头文件被重复包含：
由于头文件包含可以嵌套，那么C文件就有可能包含多次同一个头文件，就可能出现重复定义的问题的。
通过条件编译开关来避免重复包含（重复定义）
例如：

	[[ifndef]] __HEAD_FILE__
	[[define]] __HEAD_FILE__
	…
	文件内容
	…
	[[endif]]

2).得到一个制定地址上的一个字节或字

	[[define]] MEM_B(X) (*((byte*)(x)))
	[[define]] MEM_W(X) (*((word*)(x)))
3).求最大值与最小值

	[[define]] MAX(x,y)  ((x)>(y)?(x):(y))
	[[define]] MIN(x,y)  ((x)<(y)?(x):(y))
4).得到一个结构体中field所占用的字节数

	[[define]] FSIZ(type,field)  sizeof(((type*)0)->field)
5).得到一个field在结构体中的偏移量

	[[define]] FPOS(type,field)\                    //使用宏定义的换行符
	 ((dword)&(((type*)0)->field)
6).按照LSB格式把两个字节转化为一个word

	[[define]] FLIPW(ray) (((word)(ray)[0]*256)+(ray)[1])
7).按照LSB格式将一个WORD转化为两个字节

	[[define]] FLOPW(ray,val)  (ray)[0]=((val)/256);(ray)[1]=((val)&0xFF)
8).得到一个变量的地址

	[[define]] B_PTR(var) ((byte*)(void*)&(var))
	[[define]] W_PTR(var) ((word*)(void*)&(var))
9).得到一个字的高位与低位字节

	[[define]] WORD_LO(xxx) ((byte)((word)(xxx)&255))      //和低八位相与，转换为一个字节(八位)
	[[define]] WORD_HI(xxx) ((byte)((word)(xxx)>>8))       //右移八位，即丢弃高八位。
10).用宏得到一个数组所含的元素个数

	[[define]] ARR_SIZE(a) (sizeof(a)/sizeof((a)[0]))

##3.小结及说明
1) 宏定义是用宏名来表示一个字符串，**在宏展开时又以该字符串取代宏名**，这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，
预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。
2) 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起置换。
3) 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。**如要终止其作用域可使用#undef命令**。只要函数定义在#undefine之后，则函数无法使
用#define的内容。
4) 宏名在源程序中若用引号括起来，则预处理程序不对其作宏代换。
5) 宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名。在宏展开时由预处理程序层层代换。
例如：

	 [[define]] PI 3.1415926
	 [[define]] S PI*y*y          /* PI是已定义的宏名*/
6) 习惯上宏名用大写字母表示，以便于与变量区别。但也允许用小写字母。
7) 可用宏定义表示数据类型，使书写方便。
应注意用宏定义表示数据类型和用typedef定义数据说明符的区别:
**宏定义只是简单的字符串代换，是在预处理完成的，而typedef是在编译时处理的，它不是作简单的代换，而是对类型说明符重新命名。被命名的标识符具有类型定义说明的功能。**
请看下面的例子：

	[[define]] PIN1 int *
	typedef (int *) PIN2;
从形式上看这两者相似， 但在实际使用中却不相同。
下面用PIN1，PIN2说明变量时就可以看出它们的区别：

	PIN1 a,b;在宏代换后变成:
	int *a,b;
表示a是指向整型的指针变量，而b是整型变量。
然而：

	PIN2 a,b;
表示a,b都是指向整型的指针变量。因为PIN2是一个类型说明符。由这个例子可见，宏定义虽然也可表示数据类型， 但毕竟是作字符代换。在使用时要分外小心，以避出错。
8) 对“输出格式”作宏定义，可以减少书写麻烦。
例如：

	[[define]] P printf
	[[define]] D "%d\n"
	[[define]] F "%f\n"
	int main(){
	  int a=5, c=8, e=11;
	  float b=3.8, d=9.7, f=21.08;
	  P(D F,a,b);
	  P(D F,c,d);
	  P(D F,e,f);
	  return 0;
	}
9)**带参宏定义中，宏名和形参表之间不能有空格出现。**
10)**在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义。而宏调用中的实参有具体的值。要用它们去代换形参，因此必须作类型说明。**这是与函数中的情况不同的。在函数中，形参和实参是两个不同的量，各有自己的作用域，调用时要把实参值赋予形参，进行“值传递”。而在带参宏中，只是符号代换，不存在值传递的问题。
11)在宏定义中的形参是标识符，而宏调用中的实参可以是表达式。
