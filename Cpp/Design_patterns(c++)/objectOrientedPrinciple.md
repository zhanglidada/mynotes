[[面向对象的三大基本特征，五大基本特性]]
##一、三大基本特征
###1.封装
封装就是隐藏对象的实现细节，仅对外公开接口。将抽象得到的数据和行为(或功能)相结合，形成一个有机的整体，<font color = [[EDA43]]>也就是将数据与操作数据的源代码进行有机的结合，形成“类”，</font>其中数据和函数都是类的成员。封装可以控制在程序中属性的读取和修改的访问级别,保护成员属性，不让类以外的程序直接修改和访问类内成员。

封装的目的是增强安全性和简化编程，使用户不必去了解具体的实现细节，只需要通过外部接口，以特定的访问权限来使用类的成员。封装的目的是实现高内聚，低耦合。

**补充：**
耦合：各个模块之间的关联程度
内聚：一个模块内部各个部分之间的关联程度
###2.继承
![6](/assets/6_3qeieu52g.png)

####2.1意义： 用于代码重用，节省开发时间
![20180810100730507](/assets/20180810100730507_mv1z4q7zu.png)
继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

**注意：**
1.<font color = #54321>在class中，缺省的继承权限是private，struct中缺省的继承权限是public</font>。

####2.2同名隐藏:
在基类和派生类中，具有相同名称的成员(成员函数和成员表变量)，用派生类对象去访问这个同名成员，只能访问到自己的同名成员，父类的默认被隐藏了；<font color = [[EA123]]>此时可以采用加基类作用域的方式去访问父类的同名成员。</font>

####2.3.派生类的6个默认成员函数：(即我们不写，但是编译器会默认帮我们实现)
1）派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员。如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。
2）派生类的拷贝构造函数必须调用基类的拷贝构造完成基类的拷贝初始化。
3）派生类的复制运算符operator=必须要调用基类的operator=完成基类的复制。
4）派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。因为这样才能保证派生类对象先清理派生类成员再清理基类成员的顺序。
![20200327123907774](/assets/20200327123907774.png)
```
[[include]] <iostream>
[[include]] <vector>
using namespace std;
class Person {
 public:
  // 普通的构造函数,有默认的值
  Person (const char* name = "zl") : _name(name){
    cout << "Person()" << endl;
  }
  // 拷贝构造函数
  Person(const Person& p) : _name(p._name){
    cout << "Person(const Person&)" << endl;
  }
  Person& operator=(const Person& p) {
    cout << "Person operator=(const Person& p)" << endl;
    // 防止自赋值
    if (this != &p) {
      _name = p._name;
    }
    return *this;
  }
  // 普通的析构函数
  ~Person() {
    cout << "~Person()" << endl;
  }
 private:
  string _name;
};
class Student : public Person {
 public:
  // 子类的构造函数：由于父类没有默认的构造函数，所以子类需要在初始化列表中调用父类的构造函数
  // 先父后子
  Student(const char* name, int num) : Person(name) , _num(num){
    cout << "student()" << endl;
  }
  /* 拷贝构造
     在构造函数的初始化列表中，父类会切下子类中属于自己的部分进行拷贝构造
  */
  Student(const Student& st) : Person(st), _num(st._num){
    cout << "student(const Studend&)" << endl;
  }
  // 赋值运算符重载
  Student& operator=(const Student& st) {
    cout << "Student operator=(const Student& p)" << endl;
    // 防止自赋值
    if (this != &st) {
      // 显示调用父类的复制运算符
      Person :: operator=(st);
      _num = st._num;
    }
    return *this;
  }
  // 析构函数，先子后父
  ~Student() {
    cout << "~Student()" << endl;
    // 随后会调用父类的析构函数并输出
  }
 private:
  // 学号
  int _num = 0;
};

int main() {
  Student s1("jack", 12);
  // 拷贝构造
  Student s2(s1);
  Student s3("Rose", 18);

  // 复制运算
  s1 = s3;
}
```
####2.4派生类的对象模型：
**常用对象模型：**

1）单继承：一个子类只有一个直接父类的继承关系

2）多继承：一个子类具有两个或者两个以上直接父类的继承关系。

在继承中，如果一个派生类存在两个以上的基类，且基类中有同名成员，则会存在二义性问题。
![1.](/assets/1._vd1ik9trf.png)
如上图，如果A和B中存在同名成员变量m_data,则在C中直接对其访问会产生二义性问题；此时需要我们通过`域(::)`成员运算符对其指定。

**多继承的特殊形况：菱形继承：**
![3](/assets/3_161vt8xtg.png)

在多重继承，尤其是菱形继承中会存在同名的数据成员(由于重复的基类数据成员)，如下图。此时在子类中无法直接读取，需要对其进行加域读取。
![2](/assets/2_l2rvd2y00.png)

非虚继承的类内存分布：
![4](/assets/4_9e6pp7fym.png)

**解决方法：**<font color = [[B3412]]>采用虚继承：</font>
1）目的：虚继承让某个类做出声明，承诺愿意共享它的基类。这个被共享的基类就称为虚基类。(Virtual Base Class)。在间接继承共同基类成员时只保留一份基类的成员。

2）用法：在声明派生类时，在继承权限的前面加上virtual关键字即可构成虚拟继承。

**虚继承：**
虚基类的声明：
```
// 公共基类
class N {
public:
	// 基类定义了自己的构造函数，此时子类需要显示调用基类构造函数
	N(int value1, int value2, int value3) : m_data1(value1), m_data2(value2), m_data3(value3){
		cout << "m_data1: " << m_data1 << endl;
	}
	~N() {
		cout << "destructor N" << endl;
	}
private:
	int m_data1;
	int m_data2;
	int m_data3;
};
// 直接继承和虚继承的内存占用不同
class A : virtual  public N {
public:
	A(int value1) : N(11,12,13), m_a(value1){
		cout << "m_a: " << m_a << endl;
	}
	~A() {
		cout << "destruct A" << endl;
	}
private:
	int m_a;
};
class B : virtual  public N {
public:
	B(int value1) : N(21,22,23), m_b(value1){
		cout << "m_b: " << m_b << endl;
	}
	~B() {
		cout << "destruct B" << endl;
	}
private:
	int m_b;
};
class C : public A, public B {
public:
	C(int value1) : N(1,2,3),  A(2), B(3), m_c(value1) {
		cout << "m_c: " << m_c << endl;
	}
	~C() {
		cout << "destruct C" << endl;
	}
private:
	int m_c;
};
```
如下图所示：
![1](/assets/1_zvawesrvg.png)

此时对于菱形继承问题，在派生类C中就只存在一份成员变量m_data1,对其访问不会存在二义性问题。这里需要注意，在虚继承中对于共享的基类变量并不是直接存储，<font color = [[AE342]]>而是存在一个指针指向各自的偏移变量表</font>，然后再从偏移量表中取得该共享对象的地址并使用。
<font color = [[pinkblue]]>在最后的派生类中，不仅需要对其直接基类进行初始化，还需要对虚基类进行初始化！(父类A，B虽然也对虚基类进行初始化，但是只有最后的的派生类C对虚基类的初始化才真正有效)</font>

如下图所示：
![5](/assets/5_ljnjsjjc9.png)



**补充：**
观察上面虚继承的体系可以发现：<font color= [[EA234]]>必须在虚派生的真实需求出现之前就已经完成虚派生的操作。</font>在上图中，当定义C类时才出现了对虚派生的需求；但是如果A和B类不是从N类虚派生得到的，那么C类还是会保留两份N类的数据成员。<font color = [[8080c2]]>换个角度来说，虚派生只影响从指定了虚基类的派生类中进一步派生来的类，它不会影响派生类本身。</font>

在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。
![1-2006291K2591N](/assets/1-2006291K2591N.png)

**虚基类成员的可见性：**
因为在虚继承的最终派生类中只保留了一份虚基类的成员，该成员可以直接被访问且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，那么仍然可以直接访问这个被覆盖的成员。但是如果该成员被两条或多条路径覆盖了，那就不能直接访问了，此时必须指明该成员属于哪个类。

以上图中的菱形继承为例，假设 N 定义了一个名为 x 的成员变量，当我们在 C 中直接访问 x 时，会有三种可能性：
1）如果 A 和 B 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
2）如果 A 或 B 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
3）如果 A 和 B 中都定义了 x，那么直接访问 x 将产生二义性问题。

<font color = red>所以，在能不用使用多继承额情况下就尽量不要使用多继承，否则常常会产生二义性问题以及调试和维护的困难。
</font>

**虚基类的构造：**
C++编译系统只执行最后的派生类对基类的构造函数调用，而忽略其他派生类对虚基类的构造函数调用。从而避免对基类数据成员重复初始化。因此，虚基类只会构造一次。

**注意：**
1.父类对象和子类对象之间具有赋值兼容规则。其实就是类似于强制类型转换的安全性问题。

2.子类能从父类继承的以及不能从父类继承的
1）不能继承的：
构造函数，拷贝构造函数，析构函数
2）可以继承的：
静态成员变量，静态成员函数，友元函数，重载的赋值运算符

<font color = red>可以发现，静态成员变量也并不存在类的内存分布中，而是存在全局静态区域。</font>
```
[[include]] <iostream>
using namespace std;

class Base {
 public:
  // 声明静态成员变量
  static int m_data;
  // 定义静态成员函数
  static void func(int value) {
    m_data = value;
  }
  // 普通的构造函数
  Base(int num) : m_value(num){
    cout << "common constructor: " << endl;
  }
  // 友元函数
  friend ostream& operator<<(ostream& os, Base& b) {
    os << b.m_value;
    return os;
  }
  // 赋值运算符重载
  Base& operator=(Base& b) {
    m_value = b.m_value;
    return *this;
  }
 private:
  int m_value;
};
// 静态成员变量必须在类的外部声明或者定义一次
int Base :: m_data = 0;
class Test : public Base {
 public:
  Test(int value) : Base(value) {
    cout << "son's constructor:" << endl;
  }
};
int main() {
  Test x(123);
  Test y(321);
  /* 可以继承的：
     1.静态成员变量
     2.静态成员函数
     3.友元函数
     4.重载的赋值运算符
  */
  cout << Test::m_data << endl;
  Test::func(999);
  cout << y << endl;
  cout << x << endl;
  y = x;
  cout << y << endl;
}
```
![7](/assets/7_7k2dgemqh.png)
![8](/assets/8_go055cge6.png)
输出结果：
```
common constructor:
son's constructor:
common constructor:
son's constructor:
0
321
123
123
```

###3.多态
**简介：**
多态即面对同一个行为或者消息，具有多个不同表现形式或响应的能力。多态允许不同类的对象对同一消息做出响应，使得具有不同内部结构的对象可以共享相同的外部接口。这意味着虽然针对不同对象的具体操作不同，但通过一个公共的基类，他们的操作可以通过同一个方式进行调用。

####3.1优点：
1) 消除类型之间的耦合关系
2) 可替换性(多态对已存在的代码具有可替换性)
3) 可扩充性(增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作)
4) 接口性(由父类通过虚函数向子类提供一个公用的接口)
5) 灵活性(具有灵活多样的操作)
6) 简化性(多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时)

####3.2多态的实现及原理：
#####3.2.1多态存在的必要条件：
继承的存在(继承是多态的基础)，重写(多态下调用子类重写的方法)，父类指针或者引用指向子类对象(子类到父类的向上类型转换)

#####3.2.2实现：
1）简单来说，在基类的函数前加上virtual关键字，再在派生类中重写该函数，运行时根据对象的实际类型来调用相应函数(这其实就是运行时动态绑定)，此外纯虚函数是虚函数再加上 = 0; 即`virtual void func() = 0;`。

2）至少包含一个虚函数的基类称为抽象基类，**拥有纯虚函数的基类称为抽象类**，必须在子类实现父类的纯虚函数。即纯虚函数先有名称，没有内容，在派生类实现内容。

#####3.2.2 原理：
1）virtual关键字声明的函数叫做虚函数，虚函数是类的成员函数。

2）<font color = red>包含虚函数的类中都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表偏移地址的虚指针。虚表是和类对应的，虚表指针是和对象对应的。</font>

**虚函数的例子：**
```
[[include]] <iostream>
using namespace std;

class Father {
 public:
  // 父类的虚函数
  virtual void Say() {
    cout << "Say Father hello!" << endl;
  }
  void speak() {
    cout << "speak father hi!" << endl;
  }
};
class Son : public Father {
 public:
  void Say() {
    cout << "Say Son hello!" << endl;
  }
  void speak() {
    cout << "speak son hi!" << endl;
  }
};
int main() {
  Son sn = Son();
  // 向上类型转换
  Father fa = sn;
  fa.speak();  // 调用的是父类对象的成员函数
  /*
    父类指针指向子类中包含的父类地址部分
    如果没有定义虚函数则只能调用父类函数
  */
  Father *pFather = &sn;
  pFather->Say();  // 调用子类重写的虚函数函数
  pFather->speak();  // 调用父类的函数，因为不是虚函数
}
```
输出结果：
```
speak father hi!
Say Son hello!
speak father hi!
```

**从编译角度来看：**
在编译器编译过程中，要确定每个对象调用函数(非虚函数)的地址，这称之为早期绑定。当我们将Son类的对象sn的地址赋给pFather时，c++编译器进行了类型转换，此时c++编译器认为变量pFather保存的就是Father对象的地址，当在main函数中执行pFather->speak(),调用的当然就是Father对象的speak函数。但是对于虚函数则调用的是子类重写的函数，这是因为虚函数采用的是运行时期动态调用。
![9](/assets/9_8pnl7onay.png)
我们构造Son类的对象时，首先要调用Father类的构造函数去构造Father类的对象，然后才调用Son类的构造函数完成自身部分的构造。当我们将Son类对象转换为Father类型时，该对象就被认为是原对象整个内存模型的father部分，那么当我们利用类型转换后的对象指针去调用它的方法时，输出“speak father hi”，也就顺理成章了。

**一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual**。编译器针对虚函数采取晚绑定的方法(运行时动态调用)。
![10](/assets/10_2c36wn8mh.png)
此时pFather指针指向子类sn对象，针对虚函数`say()`,编译器在编译的时候，发现Father类中有虚函数，此时**编译器会为每个包含虚函数的类创建一个虚表(即vtable)**，该表是一个一维数组，在这个数组中存放每个虚函数的地址；<font color = red>为了定位虚表，编译器另外还为每个对象提供了一个虚表指针(即vptr)</font>，这个指针指向了对象所属类的虚表，**在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的虚表**，从而在调用虚函数的时候，能够找到正确的函数。针对上面的示例代码`Father *pFather = &sn;`，由于pFather实际指向的对象类型是Son，因此father中的vptr实际指向的Son类的vtable，当调用pFather->Son()时，根据虚表中的函数地址找到的就是Son类的Say()函数。

由于每个对象调用虚函数均需要通过`vptr`实现，并且在虚表指针没有正确初始化之前我们不能够去调用虚函数。在构造函数中进行虚表的创建和虚表指针的初始化。在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承者，它初始化父类地址部分的虚表指针，该虚表指针指向父类的虚表；当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。(其实子类的内存分布中含有自身的vptr以及父类内存地址中的父类vptr) (回去看看more effective c++)

**总结：**
1）如果基类有虚函数，那么基类和其子类均有虚表

2）虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现，如果重写了相应的虚函数，那么虚表中的地址就会改变，指向自身的虚函数实现；如果派生类有自己的虚函数，那么虚表中就会添加该项。

3）派生类的虚表中虚地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。

4）一般情况下(不涉及虚函数)，当我们用一个指针/引用调用一个函数的时候，被调用的函数是取决于这个指针/引用的类型。当涉及到多态性的时候，由于采用了虚函数和动态绑定，此时的调用就不会在编译时候确定而是在运行时确定。不再单独考虑指针/引用的类型而是看指针/引用的对象的类型来判断函数的调用。根据对象中虚指针指向的虚表中的函数的地址来确定调用哪个函数。

##二、五大基本原则(软件设计的原则)
###1.单一职责原则：
一个类应该有且只有一个去改变它的理由，意味着一个类应该只有一项工作，<font color = [[A23400]]>可以看作是低耦合高内聚思想的延伸，提升高内聚来减少引起变化的原因。</font>

###2.开放封闭原则(OCP):
软件实体(类、模块、函数等)应该是可扩展的，但是不可修改。因为修改程序有可能会对原来的程序造成错误，但是可以添加功能并且尽可能的在外边添加新的类。
![2018120614105316](/assets/2018120614105316_zl0i8r59r.png)

###3.里氏替换原则(Liskov Substitution Principle)
即任何基类可以出现的地方子类都一定可以出现。LSP是继承复用原则的基石；只有当衍生类可以替换基类，且软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能在基类的基础上增加新的功能。

###4.接口隔离原则
接口不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口之上。

###5.依赖倒置原则
简单来说有两点：
1) 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象模块。
2) 抽象不应该依赖于具体实现，具体实现应该依赖于抽象
