# 一.数值转换和数据的表示
## 1.数值转换
### 十进制转换为其他进制
一般采用短除法

### 二进制和十六进制互转
二进制转为16进制
四位一组，每组转换为对应的16进制符号

16进制转为2进制
每位16进制转为四位的对应二进制数



## 2.计算机内数据的表示（真值与机器数）

### 2.1 原码、反码、补码、移码


移码：
在补码的基础上将符号位取反，但是移码只能用于表示整数

![[软考/中级/图片/Pasted image 20250914160923.png]]

### 2.2 定点数和浮点数
#### 定点数：
定点数就是小数点的位置固定不变的数。小数点的位置通常有两种约定方式，分别是定点整数和定点小数。

定点整数：
纯整数，小数点在最低有效数值位之后

定点小数：
纯小数，小数点在最高有效数值位之前

#### 浮点数
浮点数就是小数点位置不固定的数，它能表示更大范围的数。

浮点数通常表示为$N = M \cdot R^e$，其中 M称为尾数，R 称为基数，E 称为阶码。
阶码决定浮点数所能表示的数值范围，尾数决定浮点数所能表示的数值精度。


### 2.3校验码

#### 码距：
一个编码系统中任意两个码字之间不同的二进制位数，也称为海明距离。计算方法是对两个码字之间进行异或操作，并统计结果中 1 的个数。

在一个有效编码集中任意两个码字的最小码距称为该编码集的海明距离。

码距的检测和纠错距离：
若码距为 d，可保证检测出 ≤ d−1 位错误
若码距为 d，可纠正 ≤ ⌊(d−1)/2⌋ 位错误。

快速理解：码距就是一个编码系统中，有多少位必须反转才能让 A 变成 B

对于检测和纠错，其实就是对于收到的编码信息，判断是否同编码系统中的字匹配，如果匹配就正确，如果不匹配就观察错误的字同编码系统中的哪个字更像，并根据码距去判断是否可以纠错。

对于匹配的时候，可能出错的位数已经超过了码距，此时虽然能匹配某个字，但是实际信息也是错误的。


#### 奇偶校验码：
校验码用来检测传输的数据是否出错。校验码中应用比较多的一般是奇偶校验码和循环冗余校验码两种。

通过在编码中增加一位校验位来使编码中1 的个数为奇数(奇校验)或者为偶数(偶校验)，从而使码距变为 2。

对于奇校验，它可以检测编码中奇数位出错的情况，但不能发现偶数位出错的情况。当编码中存在 0-> 1 / 1 -> 0 的情况，此时编码中奇数的个数发生了变化，此时可以检测到编码发生了错误。对于偶校验原理类似。


#### 循环冗余校验码：
循环冗余编码 CRC 广泛用于数据通信领域和磁介质存储系统中，它利用生成多项式为 K 个数据位产生 R个校验位来进行编码，其编码长度为 K + R。

#### 海明码
海明码的构成方法：在数据位之间插入 k 个校验码，通过扩大码距来实现检错和纠错。

设数据是 n 位，校验位是 k 位，则 n 和 k 必须满足以下关系：$2^k-1 >= n + k$


# 二 计算机系统的组成、指令和输入系统

## 2.1 计算机系统组成

冯诺伊曼计算机的结构：
冯·诺依曼计算机结构（Von Neumann Architecture）是现代计算机体系的基础，其核心思想是**​“存储程序”​**和**​“程序控制”​**
![[Pasted image 20250915072609.png]]


存储程序：
指令和数据混放在同一块可读写的随机存储器中，cpu 通过地址访问存储器中的指令和数据，程序只需要读取到内存中就能运行。

地址空间统一：
内存，寄存器，显存全部映射到同一套地址编号，cpu 用同一套 load ，store 指令就能访问任何东西

指令顺序执行：
指令按存储器中的顺序依次执行，通过**程序计数器（PC）​**指向当前指令地址，执行后自动递增。特殊情况下（如分支跳转）可修改PC值

二进制与运算-控制分离：
信息全部二进制；控制器把“操作信号”从“运算部件”里单独拎出来，通过操作码（Opcode）和操作数（Operand）区分功能。例如，操作码`0000`表示加法，操作数`0101`表示操作数地址

**工作原理：**
取指(Fetch)从存储器中读取下一条指令到控制器。
译码(Decode)​解析指令的操作码和操作数。
​执行(Execute)​运算器执行操作（如数据运算或内存访问）。
写回(Write-back)​将结果写入寄存器或存储器

执行加法指令`ADD R1, R2, R3`时，控制器先取指令，译码确定需将寄存器R2和R3的值相加，运算器执行加法后，结果存入R1


冯·诺依曼把“程序”变成了普通数据，把“硬件”变成了可无限替换的模块；
只要 PC 还在自动加一、内存还按地址取字节，我们就仍活在冯·诺依曼的宇宙里



**主存储器：**

MAR：地址寄存器，用来存放当前CPU访问的内存单元地址

MDR：数据寄存器，用来存入内存中读入/写出的信息。

**运算器：**
ACC：累加器，用于存放操作数或者运算结果

MQ：乘商寄存器，在乘、除运算时用于存放操作数或运算结果

X：通用的操作数寄存器，用于存放操作数

ALU：算数逻辑单元，内部有复杂的电路实现算数运算和逻辑运算

DR：数据缓存寄存器

PSW：状态条件寄存器，用来保存指令运行标志


**CPU 控制器：**

CU：控制单元，分析指令并给出控制信号

IR：指令寄存器，<font color=red>存放当前执行的指令</font>

PC：程序计数器，<font color=red>存放下一条指令的地址</font>，自动+1

AR：地址寄存器，保存当前 cpu 所访问的内存单元地址

ID：指令译码器，对操作码进行分析



## 2.2 指令系统

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码
一条指令通常包括操作码字段和地址码字段两个部分

### 2.2.1 CPU的七种寻址方式
寻找指令中操作数有效地址的方式称为寻址方式。

**1）立即(数)寻址:**
操作数与操作码一起放在代码段区域，直接写在指令中并<font color=red>作为指令的一部分</font>。这种操作数称为立即数，寻址方式也被称为立即数寻址。

**立即数寻址方式通常用来给寄存器赋初值。**

```
MOV AL, 05H （8位立即数）  
MOV DX, 8000H （16位立即数）
```

**2）寄存器(直接)寻址:**
指令需要的操作数存放在 CPU 内部寄存器中，例如 AX、BX、CX、DX 等。寄存器寻址方式减少了读/写存储器单元的次数，所以**使用寄存器寻址方式的指令一般执行速度比较快。**

```
MOV DS, AX
MOV AL, BL
```


**3）(存储器)直接寻址:**
操作数存放在存储器(内存)中，在指令中给出的是该操作数的有效地址EA(段内偏移地址)。操作数通常存放在数据段中，默认的段地址存放在 DS 段寄存器中。

操作数的内存地址：**DS 段地址 ×16(左移 4 位)+16 位偏移地址=20 位内存地址**。

```
MOV BX, [2000H] (假设段地址 DS=1000H)  
内存地址：1000H×16+2000H=12000H
```

**4）寄存器间接寻址:**
操作数存放在存储器中(内存中)，有效地址（端内偏移地址）存放在内部寄存器SI，DI，BX，BP中，段地址可以放在SS或DS中。

- 若段内偏移地址存放于 SI、DI、BX 之一中，默认段地址存放在 DS 寄存器中。

```
MOV AX, [SI]MOV AX, [DI]MOV AX, [BX]
```

操作数的内存地址：**DS 段地址 ×16(左移 4 位)+ [SI]/[DI]/[BX] 偏移地址 = 20 位内存地址。**

- 若段内偏移地址存放于 BP 中，默认段地址存放在寄存器 SS(堆栈段)中。

```
MOV BX, [BP]
```

操作数的内存地址：**SS 段地址 ×16(左移 4 位)+ [BP] 偏移地址=20 位内存地址。**

**5）寄存器相对寻址:**
操作数存放在存储器（内存）中，有效地址（段内偏移地址）存放在内部寄存器SI，DI，BX，BP中，段地址放在SS或DS中。

相比于寄存器间接寻址方式，寄存器相对寻址的不同之处在于多了一个 8 位或 16 位的带符号常数偏移量。

```
MOV AL, [SI-200H]
```

操作数的内存地址：**SS 或 DS 段地址 ×16(左移 4 位)+ [BP]/[SI]/[DI]/[BX]偏移地址+常数偏移量 = 20 位内存地址。**

```
MOV AL, [SI-2]    (假设 DS=3000H,SI=1000H)内存地址：3000H×16+1000H-2=30FFEH
```


**6）基址、变址寻址:**
操作数存放在存储器(内存)中，基址存放在内部寄存器BX或BP中，变址存放在内部寄存器 SI或DI中。由于段地址存放在内部寄存器 SS、DS 之一中，所以也可分为两类，类比寄存器间接寻址方式即可。

操作数内存地址：**SS 或 DS 段地址 ×16(左移 4 位)+[BP]或[BX]基址+[SI][di]变址=20 位内存地址**

```
MOV AL, [BP][DI]    (假设 SS=8000H,BP=1000H,DI=0500H)内存地址：8000H×16+1000H+0500H=81500H
```


**7）基址、变址相对寻址:**
操作数存放在存储器(内存)中，基址存放在内部寄存器 BX或BP中，变址存放在内部寄存器 SI或DI中。由于段地址存放在内部寄存器 SS或DS中，所以也可分为两类，类比寄存器间接寻址方式即可。

相比于基址、变址寻址方式，基址、变址、相对寻址的不同之处在于多了一个 8 位或 16 位的带符号常数偏移量。

```
MOV AL, 1000H[BP][DI]
```

操作数内存地址：**SS 或 DS 段地址 ×16(左移 4 位)+[BP]或[BX]基址+[SI][di]变址+常数偏移量=20 位内存地址**

```
MOV AL, 0010H[BX][SI]  (假设 DS=6000H,BX=5000H,SI=0300H)内存地址：6000H×16+5000H+0300H+0010H=65310H
```


### 2.2.2指令集分类

指令集分为复杂指令集 CISC 和精简指令集 RISC

## 2.3流水线

### 1）概念
流水线将指令拆分成多个独立阶段，让多条指令在不同阶段并行处理，目的是提高cpu的吞吐率和整体执行性能。

### 2）阶段划分

流水线将单条指令的执行拆分为多个步骤，典型阶段包括：

**取指（Fetch）​**​：从指令缓存中读取指令

​**译码（Decode）​**​：解析指令操作码和操作数

**执行（Execute）​**​：完成算术/逻辑运算

**访存（Memory Access）​**​：处理数据加载/存储

**写回（Write Back）​**​：将结果写入寄存器或内存
    
例如，Intel 486首次采用五级流水线（取指→译码→转址→执行→写回）

不同指令的各阶段操作可重叠执行。例如，当第一条指令进入译码阶段时，第二条指令即可开始取指，形成类似工厂装配线的流水作业。


### 3）计算

**流水线周期：**
流水线周期为流水线为执行时间最长的一段，因为需要保证在一个周期内可以执行完流水线中任意一个阶段。

**流水线计算公式：**
流水线执行时间是指完成n条指令所需的总时间。

流水线执行时间 = 第1条指令的执行时间 + （指令条数 - 1） * 流水线周期

也就是说，除了第一条指令需要完整的执行时间外，其余指令都只需要等待流水线周期时间即可开始执行

### 4）吞吐率和加速比
**流水线吞吐率（TP）：**
单位时间内完成的指令条数，计算公式为：TP = 指令条数 / 流水线执行时间

反应了流水线的处理能力和效率，当指令条数无穷大时 $TP \approx 1/Δt$


**流水线加速比：**
加速比是指完成同一批任务时，不使用流水线技术与使用流水线技术所需时间之比。计算公式为：S = 不使用流水线执行时间 / 使用流水线执行时间。

加速比越大，说明流水线技术带来的性能提升越明显。

### 5）流水线效率
流水线效率是指流水线实际产出与其最大产出之间的比率

### 6）实力分析：
假设某计算机系统需要执行100条指令，每条指令的执行过程包括取指（2ms）、分析（4ms）和执行（1ms）三个阶段。根据流水线技术的计算公式：

- **流水线周期** = 4ms（取最长时间段）
- **理论流水线执行时间** = 2ms + 4ms + 1ms + (100 - 1) × 4ms = 403ms
- **实际流水线执行时间**（考虑复杂性）可能略大于理论值，如408ms
- **吞吐率** = 100 / 403 ≈ 0.248（或根据实际执行时间计算）
- **加速比**（假设不使用流水线每条指令需顺序执行，总时间为700ms） = 700ms / 403ms ≈ 1.74


## 2.4 输入输出（CPU和外设之间的数据传输方式）

### 2.4.1 程序控制方式

程序控制方式是指CPU与外设间的数据传送是在程序的控制下完成的一种数据传送方式。分为无条件传送方式和查询传送方式两种。

1）无条件传送方式
所谓无条件，就是假设外设已处于就绪状态，数据传送时，程序就不必再去查询外设的状态，而直接执行I/O指令进行数据传输。


2）查询传送方式
查询传送方式在传送数据前先查询外设的状态，当外设准备好时，CPU执行I/O指令传送数据；若未准备好时，则CPU等待。

要求CPU与外设间的接口电路需要两个端口：数据端口和状态端口。

优点：能较好地协调外设与CPU之间的定时关系，因而比无条件传送方式容易实现准确传送。

缺点:该方式需要不断查询外设的状态，大量时间花在等待循环中，当主机与中、低速外设交换信息时，大大降低了CPU利用率。

### 2.4.2 中断方式
中断传送方式是指当外设需要与CPU进行信息交换时，由外设向CPU发出请求信号，使CPU暂停正在执行的程序，转去执行数据的输入/输出操作，数据传送结束后，CPU再继续执行被暂停的程序。   

优点：CPU不必查询等待，工作效率高，CPU与外设可以并行工作；由于外设具有申请中断的主动权，故系统实时性比查询方式要好得多。

缺点：采用中断传送方式的接口电路相对复杂，而且，每进行一次数据传送就要中断一次CPU。CPU每次响应中断后，都要转去执行中断处理程序，要进行断点和现场的保护和恢复，浪费了很多CPU的时间。故这种传送方式一般适合于少量的数据传送。

### 2.4.3 DMA方式
DMA控制器从CPU完全接管对总线的控制，数据交换不经过CPU，而直接在内存和I/O设备之间进行。

DMA传送方式需要一个专用接口芯片DMA控制器（DMAC）对传送过程加以控制和管理。进行DMA传送期间，CPU放弃总线控制权，将系统总线交由DMAC控制，由DMAC发出地址以及读/写信号来实现高速数据传输。传送结束后DMAC再将总线控制权交还给CPU。

DMAC中主要包括一个控制状态寄存器、一个地址寄存器和一个字节计数器，在传送开始前先要对这些寄存器进行初始化，一旦传送开始，整个过程便全部由硬件实现。

DMA方式的工作过程是： CPU 接收到I/O 设备的DMA 请求时，它给I/0 控制器发出一条命令，启动DMA 控制器，然后继续其他工作。之后CPU 就把控制操作委托给DMA 控制器，由该控制器负责处理。DMA 控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU 参与。传送完成后，DMA 控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与(预处理【设置CR、MAR、DC等】和后处理【中断处理、唤醒因该I/O阻塞的进程程等】)。


优点:传送速率很高，这对高速度大批量数据传送特别有用。

缺点:要求设置DMA控制器，电路结构复杂，硬件开销大
### 2.4.4 IO处理机(考察不多)

I/O 处理机（I/O Processor），也称为外围处理机（Peripheral Processor），是一种专门负责输入/输出操作的处理机，是DMA方式的发展。

它可以进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I/0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。

**工作流程：**
接收请求：CPU 发送 I/O 请求到 I/O 处理机。

执行操作：I/O 处理机接收请求后，执行相应的 I/O 操作，包括数据传输和处理。

返回结果：操作完成后，I/O 处理机将结果返回给 CPU。

继续执行：CPU 在接收到结果后，可以继续执行其他任务。

**与其他 I/O 控制方式的比较：**
与通道方式相比：I/O 处理机的功能更强大，结构更接近于一般处理机。

与 DMA 方式相比：DMA 方式虽然减少了 CPU 的干预，但 I/O 处理机提供了更复杂的处理能力。


# 三 存储系统，总线系统和磁盘阵列
## 3.1 存储系统

### 3.1.1 层次结构

![[Pasted image 20250924210821.png]]


**层次结构中的两套系统：**
1）主存<-->辅存：实现虚拟存储系统，解决了主存容量不足的问题，由硬件 + 操作系统实现。

2）cache <-->主存：解决了主存与 cpu 速度不匹配的问题，由硬件自动完成。
cache 中存储的是主存中部分数据的复制，用于加速 cpu 对内存中数据的获取

![[Pasted image 20250921120818.png]]

**设计原则：**
1）局部性原理：
- 时间局部性：最近访问过的数据，短期内可能再次被访问（如循环变量）；  
- 空间局部性：访问某一数据时，其相邻数据也可能被访问（如数组遍历）。  

这一原理确保了“将近期访问的数据存放在高速缓存中”是高效的策略

2）性价比平衡：  
- 高速存储（如缓存）成本高、容量小，适合存放少量热数据；  
- 低速存储（如硬盘）成本低、容量大，适合存放大量冷数据。  

层次结构通过组合不同类型的存储设备，在“速度”与“容量”之间取得最优性价比。
### 3.1.2 分类


1）按层次进行分类
![[Pasted image 20250921120846.png]]
2）按传输介质进行分类
- 半导体存储：
	原理：利用半导体器件（如晶体管）的导通/截止状态存储数据（0/1）。

	类型：
		volatile（易失性）：断电后数据丢失，如DRAM（动态随机存取存储器，比如**内存**）、SRAM（静态随机存取存储器比如 **cache**）；
		non-volatile（非易失性）：断电后数据保留，如Flash（闪存或者**固态**）、ROM（只读存储器比如**主板上的 bios 写在 ROM 上**）；
		
	特点：速度快（纳秒级）、功耗低、体积小，是缓存和内存的核心介质。

![[Pasted image 20250921143232.png]]


- 磁表面存储器： 利用磁性材料的磁化方向（正向/反向）存储数据；  
	- 类型：硬盘（HDD）、软盘（已淘汰）、磁带；  
	- 特点：容量大（TB级）、成本低、速度慢（毫秒级）、寿命长，适合辅助存储。
- 光存储器
	- 原理：利用激光在光盘表面烧蚀凹坑（或改变反射率）存储数据；  
	- 类型：CD、DVD、蓝光光盘（BD）；  
	- 特点：成本低、便携性好、速度慢，主要用于数据分发和归档。

3）按存取方式进行分类

- 相联存储器：一种特殊的存储器读取方式，它允许通过内容（Content）或标签（Tag）直接访问存储单元，而不仅仅是通过地址访问
	向相联存储器写入信息时按顺序写入，不需要地址。读出时，要求CPU给出一个相联关键字，用它和存储器中所有单元中的一部分信息进行比较，若它们相等，则将此单元中余下的信息读出。

- 随机存取存储器（RAM）：读写任何一个存储单元所需的时间都相同，与位置无关。（SRAM用于L1/L2缓存，DRAM用于主存）

- 直接存取存储器（DAM）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式进行存取。（机械硬盘）

- 顺序存取存储器（SAM）：读写一个存储单元所需的时间取决于存储单元所在的位置。（磁带）

- 只读存储器（ROM）：正常工作时只能读取，不能写入（或写入难度大），在存储BIOS、固件等固定程序会使用。

顺序存取存储器和直接存取存储器都归为串行访问存储器（读取时间和数据位置有关）。

4）按信息的可更改性进行分类

- 读写存储器：可读可写（如内存、闪存、机械硬盘等）
- 只读存储器：只能读，不能写（如电影使用的光碟）


### 3.1.3 高速缓存 cache（重点！）

#### 3.1.3.1简介：
#### cache 的组成：

**缓存行 Cache Line** 是缓存中的最小单位（cache 的行和块是一个意思）。CPU Cache 被划分成多个组Set，每个Set中还可以有多个行Cache Line，**需要注意Cache Line是CPU Cache中的基本缓存单位**，也被称为**块**（Block），每次读写是以`Cache Line`为单位，一块块地去读取。

![[Pasted image 20250921173954.png]]
CPU cache Line 由有**效标志Valid**、**Tag**、**数据块Data**这3个部分组成。其中 valid 表示当前缓存的数据是否有效，tag用来表示查找Cache Line的各种标志并存储这片连续数据的公共地址，data是真正要来缓存一片连续内存地址中的数据。


看一下 cpu cache 的整体结构：

![[Pasted image 20250921174407.png]]

这里一个 set 表示一组 cpu cache line。

#### 3.1.3.2cache 的三种地址映射：
**1）直接映射(direct-mapped)：**
![[Pasted image 20250923214921.png]]

**在内存块和缓存块之间建立起固定的映射关系，一个内存块总是映射到同一个缓存块上**

- 将内存块索引对 Cache 块个数取模，得到固定的映射位置。例如 13 号内存块映射的位置就是 13 % 8 = 5，对应 5 号 Cache 块；
- 由于取模后多个内存块会映射到同一个缓存块上，产生块冲突，所以需要在 Cache 块上增加一个 **组标记（TAG）**，标记当前缓存块存储的是哪一个内存块的数据。其实，组标记就是内存块索引的高位，而 Cache 块索引就是内存块索引的低 4 位（8 个字块需要 4 位）；
- 由于初始状态 Cache 块中的数据是空的，也是无效的。为了标识 Cache 块中的数据是否已经从内存中读取，需要在 Cache 块上增加一个 **有效位（Valid bit）** 。如果有效位为 1，则 CPU 可以直接读取 Cache 块上的内容，否则需要先从内存读取内存块填入 Cache 块，再将有效位改为 1。


优点：查找效率高，硬件设备简单，地址变换速度快。

缺点：由于每个主存块只有一个固定位置可存放，即使Cache中别的Line空着也不能占用，无法充分利用Cache空间，这样冲突概率较大。如果冲突了，这多个内存块会**不断地交替装入**固定的映射Cache Line中，导致缓存命中率降低，所以**直接映射适合大容量Cache**


**2）全相连映射(fully associative)：**
![[Pasted image 20250923215417.png]]
**允许内存块映射到任何一个 Cache 块上。** 这种方式能够充分利用 Cache 的空间，块冲突率也更低，但是所需要的电路结构物更复杂，成本更高。

具体方式：

- 1、当 Cache 块上有空闲位置时，使用空闲位置；
- 2、当 Cache 被占满时则替换出一个旧的块腾出空闲位置；
- 3、由于一个 Cache 块会映射所有内存块，因此组标记 TAG 需要扩大到与主内存块索引相同的位数，而且映射的过程需要沿着 Cache 从头到尾匹配 Cache 块的 TAG 标记。


优点：映射方式比较灵活，**Cache的利用率高，块冲突的概率低**，只有当所有的Line都被占满后才会出现冲突。

缺点：访问缓存时，每次都要和全部Line中的内存进行比较，速度低延迟高是它无法避免的缺点，因此**适合于小容量Cache采用。**


**3）组相连映射(set-associative )：**
![[Pasted image 20250923215433.png]]

**组间采用直接映射，组内采用全相联映射。** 组相联映射是直接映射和全相联映射的折中方案，将 Cache 分为多组，<font color=red>每个内存块固定映射到一个特定分组中，同时又允许该内存块映射到该组内的任意 Cache 块中。</font>

上图中 cache 分为 2 组，每一组内四个 cache line，即 4 路组相连。

当查找缓存时，不再需要全部进行遍历，只需先查到cache的组号，然后在那一组内，进行小范围遍历。这样冲突概率较小，同时命中率较高，所以这种方式在现代的处理器中得到了广泛的应用。

#### 3.1.3.3 cache 的寻址方式：
以 intel 的 cpu 举例，Intel多数处理器的 L1 Cache 都是 32KB，8路组相联，Cache Line 是 64 Byte，可以得出 Cache Line 的条数 = 32KB / 64 = 512，也就是有 512 条 cache line。那么每一路的 Cache Line 数量为  512 / 8 = 64 ，也就是每一组或者每一Set的 Cache Line 个数为 64。

我们可以得到，每一Set的容量大小 = 64 x 64B= 4096B = 4KB，正好是一个内存页page的大小！


**内存地址的分解：**

内存地址被分成了3部分：`tag, set index 和 block offset`

1）tag：与Cache Line中的tag匹配, 内存地址的前 24位

2）set index：set索引，用来寻找定位Set。内存地址中间的6个bit表示 set index。

3）block offset：块偏移量，用来寻找Cache Line里data中的内存数据，用内存地址最后6位表示。

**Cache寻址步骤：**
1）先根据`set index`来找到对应的Set

2）接着根据tag在上一步找到的set中找到对应的`Cache Line`,如果找到且cache line 上对应的有效位`valid`为1，表示缓存命中；反之无论其中的tag和`Cache Line` 里的数据内容是什么，CPU 都会直接访问主存并重新加载数据 (当然这里涉及到缓存一致性的问题)。如果没找到，说明当前发生cache缺失，即`cache miss`，此时cpu 会访问内存，获取数据的同时将内容填充到缓存中

3）最后根据`block offset`在上一步找到的Cache Line的data中找到对应内存的数据
![[Pasted image 20250922215847.png]]

4）cache 性能分析
命中率：
![[Pasted image 20250923073316.png]]

平均访问时间：
![[Pasted image 20250923073154.png]]
访问效率：
访问效率e是指cache 的访问时间与平均访问时间的比值，反映了系统的存取效率，r为主存慢于cache的倍率。

`r=tm/tc`

`e=tc/ta=tc/[htc+(1-h)tm]=1/[h+(1-h)r]=1/[r+(1-r)h]`


#### 3.1.3.4 主存的扩展：

- 地址线：地址线用于获取数据的存储单元的位置，也决定可以存放多少个存储单元。
- 数据线：数据线表示一次地址访问可以访问多少位的数据。


1）位扩展：储单元个数不变，**每个存储单元包含的数据位数（字长）增加**
![[Pasted image 20250926072442.png]]

2）字扩展：每个存储单元中存储的数据位数不变，但是存储单元的个数增加

![[Pasted image 20250926072913.png]]

**低位的地址线与各存储芯片的地址线并联，多余的高位地址线用来产生相应的片选信号。**

3）字位扩展：将字扩展和位扩展结合起来，存储单元的个数和每个存储单元内存储数据的位数都增加。

扩展方法：
先扩展位宽，形成满足位要求的存储芯片组，再对芯片组进行字扩展，也就是**先变宽，再变长。**

![[Pasted image 20250926073848.png]]

#### 3.1.3.5 虚拟存储器：
1）定义
- 虚拟存储器是一种计算机内存管理技术，它将计算机系统中的**物理内存和磁盘空间结合起来**，形成一个虚拟的内存空间，使得应用程序可以访问比物理内存更大的内存空间。虚拟存储器的实现需要操作系统的支持，它通过将**内存中的数据分成若干个页面（或称为页）**，并将这些页面映射到磁盘上的页面文件中，从而实现了内存和磁盘之间的数据交换。

2）特征
- 多次性：
    无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
    
    对应传统的一次性。
    
- 对换性：
    在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。  
    
    对应传统的驻留性。
    
- 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

#### 3.1.3.5 磁盘存储器：

存取时间 = 寻道时间 + 等待时间（平均定位时间 + 转动延迟）


## 3.2 总线系统
### 3.2.1 片内总线（内部总线）
芯片内部总线，是cpu芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接总线。

### 3.2.2 系统总线

系统总线是计算机系统各功能部件（CPU，主存，IO接口）之间互相连接的总线。可以分为数据总线，地址总线和控制总线三种。

### 3.3.3 通信总线（外部总线）

用于设备一级的互联，计算机可以通过该总线和其他设备进行信息与数据交换

## 3.3 磁盘阵列技术（RAID）

RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。

![[Pasted image 20251004230047.png]]

## 3.4 计算机可靠性
计算机可靠性指的是从它开始运行t0，到某个时刻t1这段时间内能正常运行的概率，用R(t)表示。

串联部件的可靠性：各个部件可靠性的乘积

并联部件的可靠性：1 - 各个部件失效性的乘积


# 二.数据结构和算法
## 2.1基本概念
程序 = 数据结构 + 算法

算法的五个特性：有穷性、确定性、可行性、输入、输出

算法效率的度量：时间复杂度 + 空间复杂度

时间复杂度：
时间开销与问题规模n 之间的关系

空间复杂度：
空间开销（内存开销）与问题规模 n 之间的关系。空间复杂度 = 递归调用的深度


![[Pasted image 20251005104824.png]]


## 2.2 线性表，广义表

## 2.3 树和二叉树、图
### 2.3.1 树和二叉树

二叉树的遍历：
前序遍历：根左右
中序遍历：左根右
后序遍历：左右根
层次遍历：按层遍历二叉树


树和二叉树的转换，对于每个节点从上到下、从左到右遵循以下规则进行转换：
其左孩子节点 --> 自己的左子树节点
其右兄弟节点 --> 自己的右子树节点


二叉排序树的特点：
对于每个节点的值，其左孩子的值小于根，右孩子的值大于根

构造霍夫曼树（最优二叉树）：
在给定节点序列中不断选取值最小的两个节点构成一颗二叉树

线索二叉树：
节点中不仅存储了节点的值，还存储了节点的前序或者后序的指向信息
因为非叶子节点中的每个节点都额外存储了左右孩子的信息，所以线索二叉树中的线索是存储在叶子节点中的，即叶子节点中的左右孩子指针存储了线索信息。

平衡二叉树：
任意节点的左右子树深度之差的绝对值不超过 1

### 2.3.2 图
有向图：节点之间的边有方向

无向图：节点之间的边没有方向

完全图：
在无向图中，如果每对顶点之间都有一条边相连，则此图为完全图
在有向图中，如果每对顶点之间都有两条有向边相互连接，则此图为完全图

度，入度与出度：
度用于表示无向图的每个节点有几条连线与别的节点相连
入度和出度则用于表示有向图的每个节点，从其出发和指向自己的边分别是多少

图的存储结构：
1）邻接矩阵
用一个 n 阶方阵 R 来存放图中各节点的关联信息，其矩阵元素$R_{ij}$定义为:
$$R_{ij} = \begin{Bmatrix}
			1 & 若顶点 i 到顶点 j 有邻接边 \\
			2 & 若顶点 i 到顶点 j 无邻接边
		   \end{Bmatrix}$$

 2）邻接表
 用一个一维数组顺序存储每个节点，每个数组元素上都挂一个链表，表示此节点的所有邻接节点。（类似于 hash 挂链）

图的遍历：
1）深度优先：
任意选择一个顶点作为遍历的起始节点，选择一个与该节点相连且未被访问过的节点作为下一个访问节点，下一个节点也采取类似操作。如果某个节点所有的相邻节点都被访问过，则回退到上一个节点，并从上一个节点的所有相邻节点中选一个未被访问过的节点继续遍历。

2）广度优先：
任意选择一个节点作为起始节点，依次访问与其相连的所有邻接节点，并依次对这些邻接节点做同样的操作。

图的拓扑排序：
拓扑排序是一个有向无环图的所有顶点的线性序列，且该序列满足两个条件：
1）每个顶点出现且只出现一次。
2）若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。


最小生成树：

给定一张无向联通图，如果它的子图中任意两个顶点都是互相连通，并且是一个树结构，那么这棵树叫做生成树。当连接顶点之间的图有权重时，权重之和最小的树结构为最小生成树！

1）prim 算法：
Prim 算法是一种“加点式”贪心算法，用于在连通无向加权图中求得最小生成树（MST）。它从某一顶点开始，逐步扩展一棵树，每次把“离树最近”的顶点及其对应边拉进来（**树中的所有顶点都被包含在集合中，离树最近的距离就是集合外的顶点离集合中某个顶点的最近距离**），直到所有顶点都包含在这棵树中。

2）Kruskal算法：
Kruskal 算法是一种“加边式”贪心算法，其核心思路是”先把边按权值从小到大排好，然后一条一条加“。需要注意的是在加边的过程中需要保证联通分量不会形成环。

kruskal 算法需要使用并查集来统计所有已经加入边的邻接顶点。

### 2.3.3 查找、排序








引用文档：
https://blog.csdn.net/OYMNCHR/article/details/119119136
https://zhuanlan.zhihu.com/p/1952330161077846156
https://mp.weixin.qq.com/s?__biz=MzI0ODU0NDI1Mg==&mid=2247570306&idx=3&sn=4709b742087bda1588b514d490e61649&poc_token=HOTDz2ijn2kPiGuS4XsfZnRVA7Ck9v8YVRsAtHXH
https://blog.csdn.net/m0_61789994/article/details/130696338

markdown 以及 latex 公式：
https://zhuanlan.zhihu.com/p/450465546