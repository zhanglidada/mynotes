# 一.数值转换和数据的表示
## 1.数值转换
### 十进制转换为其他进制
一般采用短除法

### 二进制和十六进制互转
二进制转为16进制
四位一组，每组转换为对应的16进制符号

16进制转为2进制
每位16进制转为四位的对应二进制数



## 2.计算机内数据的表示（真值与机器数）

### 2.1 原码、反码、补码、移码


移码：
在补码的基础上将符号位取反，但是移码只能用于表示整数

![[软考/中级/图片/Pasted image 20250914160923.png]]

### 2.2 定点数和浮点数
#### 定点数：
定点数就是小数点的位置固定不变的数。小数点的位置通常有两种约定方式，分别是定点整数和定点小数。

定点整数：
纯整数，小数点在最低有效数值位之后

定点小数：
纯小数，小数点在最高有效数值位之前

#### 浮点数
浮点数就是小数点位置不固定的数，它能表示更大范围的数。

浮点数通常表示为$N = M \cdot R^e$，其中 M称为尾数，R 称为基数，E 称为阶码。
阶码决定浮点数所能表示的数值范围，尾数决定浮点数所能表示的数值精度。


### 2.3校验码

#### 码距：
一个编码系统中任意两个码字之间不同的二进制位数，也称为海明距离。计算方法是对两个码字之间进行异或操作，并统计结果中 1 的个数。

在一个有效编码集中任意两个码字的最小码距称为该编码集的海明距离。

码距的检测和纠错距离：
若码距为 d，可保证检测出 ≤ d−1 位错误
若码距为 d，可纠正 ≤ ⌊(d−1)/2⌋ 位错误。

快速理解：码距就是一个编码系统中，有多少位必须反转才能让 A 变成 B

对于检测和纠错，其实就是对于收到的编码信息，判断是否同编码系统中的字匹配，如果匹配就正确，如果不匹配就观察错误的字同编码系统中的哪个字更像，并根据码距去判断是否可以纠错。

对于匹配的时候，可能出错的位数已经超过了码距，此时虽然能匹配某个字，但是实际信息也是错误的。


#### 奇偶校验码：
校验码用来检测传输的数据是否出错。校验码中应用比较多的一般是奇偶校验码和循环冗余校验码两种。

通过在编码中增加一位校验位来使编码中1 的个数为奇数(奇校验)或者为偶数(偶校验)，从而使码距变为 2。

对于奇校验，它可以检测编码中奇数位出错的情况，但不能发现偶数位出错的情况。当编码中存在 0-> 1 / 1 -> 0 的情况，此时编码中奇数的个数发生了变化，此时可以检测到编码发生了错误。对于偶校验原理类似。


#### 循环冗余校验码：
循环冗余编码 CRC 广泛用于数据通信领域和磁介质存储系统中，它利用生成多项式为 K 个数据位产生 R个校验位来进行编码，其编码长度为 K + R。

#### 海明码
海明码的构成方法：在数据位之间插入 k 个校验码，通过扩大码距来实现检错和纠错。

设数据是 n 位，校验位是 k 位，则 n 和 k 必须满足以下关系：$2^k-1 >= n + k$


# 二 计算机系统的组成、指令和输入系统

## 2.1 计算机系统组成

冯诺伊曼计算机的结构：
冯·诺依曼计算机结构（Von Neumann Architecture）是现代计算机体系的基础，其核心思想是**​“存储程序”​**和**​“程序控制”​**
![[Pasted image 20250915072609.png]]


存储程序：
指令和数据混放在同一块可读写的随机存储器中，cpu 通过地址访问存储器中的指令和数据，程序只需要读取到内存中就能运行。

地址空间统一：
内存，寄存器，显存全部映射到同一套地址编号，cpu 用同一套 load ，store 指令就能访问任何东西

指令顺序执行：
指令按存储器中的顺序依次执行，通过**程序计数器（PC）​**指向当前指令地址，执行后自动递增。特殊情况下（如分支跳转）可修改PC值

二进制与运算-控制分离：
信息全部二进制；控制器把“操作信号”从“运算部件”里单独拎出来，通过操作码（Opcode）和操作数（Operand）区分功能。例如，操作码`0000`表示加法，操作数`0101`表示操作数地址

**工作原理：**
取指(Fetch)从存储器中读取下一条指令到控制器。
译码(Decode)​解析指令的操作码和操作数。
​执行(Execute)​运算器执行操作（如数据运算或内存访问）。
写回(Write-back)​将结果写入寄存器或存储器

执行加法指令`ADD R1, R2, R3`时，控制器先取指令，译码确定需将寄存器R2和R3的值相加，运算器执行加法后，结果存入R1


冯·诺依曼把“程序”变成了普通数据，把“硬件”变成了可无限替换的模块；
只要 PC 还在自动加一、内存还按地址取字节，我们就仍活在冯·诺依曼的宇宙里



**主存储器：**

MAR：地址寄存器

MDR：数据寄存器

**运算器：**
ACC：累加器，用于存放操作数或者运算结果

MQ：乘商寄存器，在乘、除运算时用于存放操作数或运算结果

X：通用的操作数寄存器，用于存放操作数

ALU：算数逻辑单元，内部有复杂的电路实现算数运算和逻辑运算

DR：数据缓存寄存器

PSW：状态条件寄存器，用来保存指令运行标志


**CPU 控制器：**

CU：控制单元，分析指令并给出控制信号

IR：指令寄存器，<font color=red>存放当前执行的指令</font>

PC：程序计数器，<font color=red>存放下一条指令的地址</font>，自动+1

AR：地址寄存器，保存当前 cpu 所访问的内存单元地址

ID：指令译码器，对操作码进行分析



## 2.2 指令系统

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码
一条指令通常包括操作码字段和地址码字段两个部分

### 2.2.1 CPU的七种寻址方式
寻找指令中操作数有效地址的方式称为寻址方式。

**1）立即(数)寻址:**
操作数与操作码一起放在代码段区域，直接写在指令中并<font color=red>作为指令的一部分</font>。这种操作数称为立即数，寻址方式也被称为立即数寻址。

**立即数寻址方式通常用来给寄存器赋初值。**

```
MOV AL, 05H （8位立即数）  
MOV DX, 8000H （16位立即数）
```

**2）寄存器(直接)寻址:**
指令需要的操作数存放在 CPU 内部寄存器中，例如 AX、BX、CX、DX 等。寄存器寻址方式减少了读/写存储器单元的次数，所以**使用寄存器寻址方式的指令一般执行速度比较快。**

```
MOV DS, AX
MOV AL, BL
```


**3）(存储器)直接寻址:**
操作数存放在存储器(内存)中，在指令中给出的是该操作数的有效地址EA(段内偏移地址)。操作数通常存放在数据段中，默认的段地址存放在 DS 段寄存器中。

操作数的内存地址：**DS 段地址 ×16(左移 4 位)+16 位偏移地址=20 位内存地址**。

```
MOV BX, [2000H] (假设段地址 DS=1000H)  
内存地址：1000H×16+2000H=12000H
```

**4）寄存器间接寻址:**
操作数存放在存储器中(内存中)，有效地址（端内偏移地址）存放在内部寄存器SI，DI，BX，BP中，段地址可以放在SS或DS中。

- 若段内偏移地址存放于 SI、DI、BX 之一中，默认段地址存放在 DS 寄存器中。

```
MOV AX, [SI]MOV AX, [DI]MOV AX, [BX]
```

操作数的内存地址：**DS 段地址 ×16(左移 4 位)+ [SI]/[DI]/[BX] 偏移地址 = 20 位内存地址。**

- 若段内偏移地址存放于 BP 中，默认段地址存放在寄存器 SS(堆栈段)中。

```
MOV BX, [BP]
```

操作数的内存地址：**SS 段地址 ×16(左移 4 位)+ [BP] 偏移地址=20 位内存地址。**

**5）寄存器相对寻址:**
操作数存放在存储器（内存）中，有效地址（段内偏移地址）存放在内部寄存器SI，DI，BX，BP中，段地址放在SS或DS中。

相比于寄存器间接寻址方式，寄存器相对寻址的不同之处在于多了一个 8 位或 16 位的带符号常数偏移量。

```
MOV AL, [SI-200H]
```

操作数的内存地址：**SS 或 DS 段地址 ×16(左移 4 位)+ [BP]/[SI]/[DI]/[BX]偏移地址+常数偏移量 = 20 位内存地址。**

```
MOV AL, [SI-2]    (假设 DS=3000H,SI=1000H)内存地址：3000H×16+1000H-2=30FFEH
```


**6）基址、变址寻址:**
操作数存放在存储器(内存)中，基址存放在内部寄存器BX或BP中，变址存放在内部寄存器 SI或DI中。由于段地址存放在内部寄存器 SS、DS 之一中，所以也可分为两类，类比寄存器间接寻址方式即可。

操作数内存地址：**SS 或 DS 段地址 ×16(左移 4 位)+[BP]或[BX]基址+[SI][di]变址=20 位内存地址**

```
MOV AL, [BP][DI]    (假设 SS=8000H,BP=1000H,DI=0500H)内存地址：8000H×16+1000H+0500H=81500H
```


**7）基址、变址相对寻址:**
操作数存放在存储器(内存)中，基址存放在内部寄存器 BX或BP中，变址存放在内部寄存器 SI或DI中。由于段地址存放在内部寄存器 SS或DS中，所以也可分为两类，类比寄存器间接寻址方式即可。

相比于基址、变址寻址方式，基址、变址、相对寻址的不同之处在于多了一个 8 位或 16 位的带符号常数偏移量。

```
MOV AL, 1000H[BP][DI]
```

操作数内存地址：**SS 或 DS 段地址 ×16(左移 4 位)+[BP]或[BX]基址+[SI][di]变址+常数偏移量=20 位内存地址**

```
MOV AL, 0010H[BX][SI]  (假设 DS=6000H,BX=5000H,SI=0300H)内存地址：6000H×16+5000H+0300H+0010H=65310H
```


### 2.2.2指令集分类

指令集分为复杂指令集 CISC 和精简指令集 RISC

## 2.3流水线

### 1）概念
流水线将指令拆分成多个独立阶段，让多条指令在不同阶段并行处理，目的是提高cpu的吞吐率和整体执行性能。

### 2）阶段划分

流水线将单条指令的执行拆分为多个步骤，典型阶段包括：

**取指（Fetch）​**​：从指令缓存中读取指令

​**译码（Decode）​**​：解析指令操作码和操作数

**执行（Execute）​**​：完成算术/逻辑运算

**访存（Memory Access）​**​：处理数据加载/存储

**写回（Write Back）​**​：将结果写入寄存器或内存
    
例如，Intel 486首次采用五级流水线（取指→译码→转址→执行→写回）

不同指令的各阶段操作可重叠执行。例如，当第一条指令进入译码阶段时，第二条指令即可开始取指，形成类似工厂装配线的流水作业。


### 3）计算

**流水线周期：**
流水线周期为流水线为执行时间最长的一段，因为需要保证在一个周期内可以执行完流水线中任意一个阶段。

**流水线计算公式：**
流水线执行时间是指完成n条指令所需的总时间。

流水线执行时间 = 第1条指令的执行时间 + （指令条数 - 1） * 流水线周期

也就是说，除了第一条指令需要完整的执行时间外，其余指令都只需要等待流水线周期时间即可开始执行

### 4）吞吐率和加速比
**流水线吞吐率（TP）：**
单位时间内完成的指令条数，计算公式为：TP = 指令条数 / 流水线执行时间

反应了流水线的处理能力和效率，当指令条数无穷大时 $TP \approx 1/Δt$


**流水线加速比：**
加速比是指完成同一批任务时，不使用流水线技术与使用流水线技术所需时间之比。计算公式为：S = 不使用流水线执行时间 / 使用流水线执行时间。

加速比越大，说明流水线技术带来的性能提升越明显。

### 5）流水线效率
流水线效率是指流水线实际产出与其最大产出之间的比率

### 6）实力分析：
假设某计算机系统需要执行100条指令，每条指令的执行过程包括取指（2ms）、分析（4ms）和执行（1ms）三个阶段。根据流水线技术的计算公式：

- **流水线周期** = 4ms（取最长时间段）
- **理论流水线执行时间** = 2ms + 4ms + 1ms + (100 - 1) × 4ms = 403ms
- **实际流水线执行时间**（考虑复杂性）可能略大于理论值，如408ms
- **吞吐率** = 100 / 403 ≈ 0.248（或根据实际执行时间计算）
- **加速比**（假设不使用流水线每条指令需顺序执行，总时间为700ms） = 700ms / 403ms ≈ 1.74


## 2.4 输入输出（CPU和外设之间的数据传输方式）

### 2.4.1 程序控制方式

程序控制方式是指CPU与外设间的数据传送是在程序的控制下完成的一种数据传送方式。分为无条件传送方式和查询传送方式两种。

1）无条件传送方式
所谓无条件，就是假设外设已处于就绪状态，数据传送时，程序就不必再去查询外设的状态，而直接执行I/O指令进行数据传输。


2）查询传送方式
查询传送方式在传送数据前先查询外设的状态，当外设准备好时，CPU执行I/O指令传送数据；若未准备好时，则CPU等待。

要求CPU与外设间的接口电路需要两个端口：数据端口和状态端口。

优点：能较好地协调外设与CPU之间的定时关系，因而比无条件传送方式容易实现准确传送。

缺点:该方式需要不断查询外设的状态，大量时间花在等待循环中，当主机与中、低速外设交换信息时，大大降低了CPU利用率。

### 2.4.2 中断方式
中断传送方式是指当外设需要与CPU进行信息交换时，由外设向CPU发出请求信号，使CPU暂停正在执行的程序，转去执行数据的输入/输出操作，数据传送结束后，CPU再继续执行被暂停的程序。   

优点：CPU不必查询等待，工作效率高，CPU与外设可以并行工作；由于外设具有申请中断的主动权，故系统实时性比查询方式要好得多。

缺点：采用中断传送方式的接口电路相对复杂，而且，每进行一次数据传送就要中断一次CPU。CPU每次响应中断后，都要转去执行中断处理程序，要进行断点和现场的保护和恢复，浪费了很多CPU的时间。故这种传送方式一般适合于少量的数据传送。

### 2.4.3 DMA方式
DMA控制器从CPU完全接管对总线的控制，数据交换不经过CPU，而直接在内存和I/O设备之间进行。

DMA传送方式需要一个专用接口芯片DMA控制器（DMAC）对传送过程加以控制和管理。进行DMA传送期间，CPU放弃总线控制权，将系统总线交由DMAC控制，由DMAC发出地址以及读/写信号来实现高速数据传输。传送结束后DMAC再将总线控制权交还给CPU。

DMAC中主要包括一个控制状态寄存器、一个地址寄存器和一个字节计数器，在传送开始前先要对这些寄存器进行初始化，一旦传送开始，整个过程便全部由硬件实现。

DMA方式的工作过程是： CPU 接收到I/O 设备的DMA 请求时，它给I/0 控制器发出一条命令，启动DMA 控制器，然后继续其他工作。之后CPU 就把控制操作委托给DMA 控制器，由该控制器负责处理。DMA 控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU 参与。传送完成后，DMA 控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与(预处理【设置CR、MAR、DC等】和后处理【中断处理、唤醒因该I/O阻塞的进程程等】)。


优点:传送速率很高，这对高速度大批量数据传送特别有用。

缺点:要求设置DMA控制器，电路结构复杂，硬件开销大
### 2.4.4 IO处理机(考察不多)

I/O 处理机（I/O Processor），也称为外围处理机（Peripheral Processor），是一种专门负责输入/输出操作的处理机，是DMA方式的发展。

它可以进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I/0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。

**工作流程：**
接收请求：CPU 发送 I/O 请求到 I/O 处理机。

执行操作：I/O 处理机接收请求后，执行相应的 I/O 操作，包括数据传输和处理。

返回结果：操作完成后，I/O 处理机将结果返回给 CPU。

继续执行：CPU 在接收到结果后，可以继续执行其他任务。

**与其他 I/O 控制方式的比较：**
与通道方式相比：I/O 处理机的功能更强大，结构更接近于一般处理机。

与 DMA 方式相比：DMA 方式虽然减少了 CPU 的干预，但 I/O 处理机提供了更复杂的处理能力。


# 三 存储系统，总线系统和磁盘阵列




