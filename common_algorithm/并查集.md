并查集（Union-Find）是一种高效处理 动态连通性问题 的数据结构，用于管理一组不相交集合的合并与查询操作。

# 一、核心概念

1.核心功能：
1）查询（Find）：确定两个元素是否属于同一集合。（确定元素所属集合的根节点）

2）合并（Union）：将两个集合合并为一个集合。（调整根节点的父子关系实现）


2.基本概念：
​1）集合表示​：
每个集合用一棵树表示，树的根节点作为集合的唯一标识。元素通过父节点指针逐层指向根节点，形成层次结构。
​
​2）优化策略​：

​路径压缩​：在查找过程中，将路径上的所有节点直接指向根节点，减少后续查询的路径长度。

​按秩合并​：根据树的秩（高度或大小）合并，将秩较小的树合并到秩较大的树下，避免树退化为链表


# 二、实现方式

1.数据结构

**父节点数组（parent）​**​：记录每个元素的父节点，根节点的父节点指向自身。

**秩数组（rank/size）​**​：记录树的秩（高度或大小），用于按秩合并。

2.初始化

所有元素初始时自成一个集合，父节点指向自身，秩初始化为1：

```
for (int i = 0; i < n; i++) {
    parent[i] = i;
    rank[i] = 1;
}
```

3.查找操作（带路径压缩）

递归或迭代实现，查找根节点的同时压缩路径：

```
int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]); // 路径压缩
    }
    return parent[x];
}
```

4.合并操作（按秩合并）

比较两集合的秩，将秩较小的树合并到秩较大的树下：

```
void unionSets(int x, int y) {
    int rootX = find(x);
    int rootY = find(y);
    if (rootX != rootY) {
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else {
            parent[rootY] = rootX;
            if (rank[rootX] == rank[rootY]) {
                rank[rootX]++;
            }
        }
    }
}
```

# 三、时间复杂度与性能
​
1.时间复杂度​：
使用路径压缩和按秩合并后，单次操作的平均时间复杂度为 O(α(n))，其中 α(n)是阿克曼函数的反函数，增长极其缓慢，可视为常数。

2.​空间复杂度​：O(n)，仅需存储父节点和秩数组。


# 四、典型应用场景
​1.连通性问题​

判断网络中两台计算机是否连通。
动态检测图的连通分量（如岛屿数量问题）。
​
2.最小生成树（Kruskal算法）​​
通过并查集检测边是否形成环，高效构建最小生成树。

3.​社交网络分析​
判断用户是否属于同一朋友圈（如“六度分隔”理论中的关系链）。

4.​动态集合管理​
处理频繁的合并与查询操作，如在线算法中的实时分组问题。

