#linux下常用的一些指令
###1.ldd命令：
ldd命令本身不是一个程序，它是一个脚本，用于查看一个文件所需要的动态链接库

###2.nm命令：
nm即names的缩写，是用于列出某些文件中的符号，说白了就是一些函数和全局变量等等。

###3.c++ filt命令：
c++filt 命令可用于解析C++和Java中被修饰的符号，比如变量与函数名称。

###4.scp远程传输文件：
上传：
`scp -r 本地文件路径 用户名@ip:远程服务器文件存放路径`

下载：
`scp -r username@ip:/src/filename  des`

###5.xhsell服务器和主机之间传输文件：
`rz命令，打开窗口进行文件传输`

###6.给普通用户分配sudo权限：
1). 进入sudo用户，`chmod u+w /etc/sudoers`：表示给sudoers文件配置写权限。

2). 编辑`/etc/sudoers`，找到`root ALL=(ALL) ALL`的位置，在下面添加`username ALL=(ALL) ALL`，保存并推出。

3). 最后，`chmod u-w /etc/sudoers`，表示撤销文件的写权限。

###7.linux中grep命令使用：
<font color=red>grep是linux中的一个文本搜索工具。</font>
**grep命令常用格式：`grep  [选项]  ”模式“  [文件]`**，在这里，grep家族总共有三个成员：grep，egrep，fgrep
####1). 常用选项：

	-E ：开启扩展（Extend）的正则表达式。
	-i ：忽略大小写（ignore case）。
	-v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。
	-n ：显示行号
	-w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配liker
	-c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。
	-o ：只显示被模式匹配到的字符串。
	--color :将匹配到的内容以颜色高亮显示。
	-A  n：显示匹配到的字符串所在的行及其后n行，（after）
	-B  n：显示匹配到的字符串所在的行及其前n行，（before）
	-C  n：显示匹配到的字符串所在的行及其前后各n行，（context）

####2). 模式部分：
1、直接输入要匹配的字符串，这个可以用fgrep（即fast grep）代替来提高查找速度，比如我要匹配一下hello.c文件中printf的个数：fgrep  -c  "printf"  hello.c

2、使用基本正则表达式：
**匹配字符：**
```
[.] ：点表示匹配任意一个字符。
[abc] ：表示匹配一个字符，这个字符必须是abc中的一个。
[a-zA-Z] ：表示匹配一个字符，这个字符必须是a-z或A-Z这52个字母中的一个。
[^123] ：匹配一个字符，这个字符是除了1、2、3以外的所有字符。(注意，‘^’是非的意思)
```
对于一些常用的字符集，系统做了定义：
```
[A-Za-z] 等价于 [[:alpha:]]
[0-9] 等价于 [[:digit:]]
[A-Za-z0-9] 等价于 [[:alnum:]]
tab,space 等空白字符 [[:space:]]
[A-Z] 等价于 [[:upper:]]
[a-z] 等价于 [[:lower:]]
标点符号 [[:punct:]]
```
**匹配次数：**
```
\{m,n\} ：匹配其前面出现的字符至少m次，至多n次。
\? ：匹配其前面出现的内容0次或1次，等价于\{0,1\}。
*：匹配其前面出现的内容任意次，等价于\{0,\}，所以 ".*" 表示匹配任意字符任意次，即无论什么内容全部匹配。
```
**位置锚定：**
```
^ ：锚定行首
$ ：锚定行尾。**技巧："^$"用于匹配空白行。**
\bword或\<word：锚定单词的词首。如"\blike"不会匹配alike，但是会匹配liker
word\b或word\>：锚定单词的词尾。如"\blike\b"不会匹配alike和liker，只会匹配like
\B ：与\b作用相反。
```
**分组及引用：**
```
\(string\) ：<font color=#8956>将string作为一个整体方便后面引用。</font>
\1 ：引用第1个左括号及其对应的右括号所匹配的内容。
\2 ：引用第2个左括号及其对应的右括号所匹配的内容。
\n ：引用第n个左括号及其对应的右括号所匹配的内容。
```
**匹配以相同字母开始和结尾的行:**
![1](/assets/1_s93gqdf9f.png)

####3). 扩展的（Extend）正则表达式（注意要使用扩展的正则表达式要加-E选项，或者直接使用egrep）：
**匹配字符：**这部分和基本正则表达式一样

**匹配次数：**
```
* ：和基本正则表达式一样，表示匹配前面出现的字符任意次。
? ：基本正则表达式是\?，二这里没有\（即去掉了转意字符）表示匹配前面出现 的字符零次或者一次。
{m,n} ：相比基本正则表达式也是没有了\，表示匹配前面出现的字符m到n次。
+ ：匹配其前面的字符至少一次，相当于{1,}。
**位置锚定：**和基本正则表达式一样。
```
**分组及引用：**
```
(string) ：相比基本正则表达式也是没有了\。
\1 ：引用部分和基本正则表达式一样。
\n ：引用部分和基本正则表达式一样。　　　　　
```
　　　　　
**或者：**
a|b ：匹配a或b，**注意a是指 | 的左边的整体，b也同理。**比如 C|cat 表示的是 C或cat，而不是Cat或cat，如果要表示Cat或cat，则应该写为 (C|c)at 。记住(string)除了用于引用还用于分组。

<font color=#59862>注1：默认情况下，正则表达式的匹配工作在贪婪模式下，也就是说它会尽可能长地去匹配，比如某一行有字符串 abacb，如果搜索内容为 "a.*b" 那么会直接匹配 abacb这个串，而不会只匹配ab或acb。

注2：所有的正则字符，如 [ 、* 、( 等，若要搜索 * ，而不是想把 * 解释为重复先前字符任意次，可以使用 `\* `来转义。</font>
　　　　　　
###8.linux管道命令的使用：　　
**管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。**

<font color=#569856>管道命令使用`|`作为界定符号，仅能处理standard output,对于standard error output会予以忽略。`less,more,head,tail...`都是可以接受standard input的命令，所以他们是管道命令。
但是`ls,cp,mv`并不会接受standard input的命令，所以他们就不是管道命令了。**管道命令必须要能够接受来自前一个命令的数据作为standard input继续传递给下一个命令处理才行。**</font>　　　　

####1). 一个例子：　　　
`ls -al /etc | less`，这里通过管道将`ls -al`的输出作为 下一个命令`less`的输入，方便浏览。
![1](/assets/1_fn59mtb7f.webp)

####2). 选取命令：`cut，grep`
**cut命令：**从某一行信息中取出某部分我们想要的信息
```
cut -d '分隔字符' -f field // 根据指定的分隔字符进行分割
cut -c 字符范围
[参数说明]
-d : 后面接分隔字符,通常与 -f 一起使用
-f : 根据-d 将信息分隔成数段，-f 后接数字 表示取出第几段
-c : 以字符为单位取出固定字符区间的信息
```
例子1：打印/etc/passwd文件中以`:`为分隔符的第1个字段和第6个字段。
`cat /etc/passwd | cut -d ":" -f 1,6`
![2](/assets/2_791d8dbaz.png)　

例子2：打印/etc/passwd文件中每一行的前10个字符：
`cat /etc/passwd | cut -c 1-10`　　　
![3](/assets/3_z0yogznm2.png)　　

**注：cut在处理多空格相连的数据时候会比较吃力。**　　　　
　　　　　　
**grep命令：**分析一行信息，如果其中有我们需要的信息，就将该行取出。
```
grep [-acinv] [--color=auto] '要查找的字符串'  file
[参数：]
-a : 将binary文件以text文件的方式查找数据
-c : 计算找到 '要查找字符串'的次数
-i : 忽略大小写的不同
-n : 输出行号
-v : 反向选择，显示没有查找内容的行
--color=auto : 将找到的关键字部分加上颜色显示
```
　
####3). 排序命令：`sort,wc,uniq`　　　　
**sort：**
```
sort [-fbMnrutk] [file or stdin]
[参数]
-f ：忽略大小写的差异，例如A 与a 视为编码相同（gnore-case ）
-b ：忽略最前面的空格部分（ignore-leading-blanks）
-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法（month-sort）
-n ：使用『纯数字』进行排序默认是以文字型态来排序的（number-sort）
-r ：反向排序（reverse）
-R：根据随机hash 排序（Random-sort）
-u ：就是uniq ，相同的资料中，仅出现一行代表（unique）
-t ：分隔符号，预设是用[tab] 键来分隔（tab）
-k ：以那个区间(field) 来进行排序的意思（key）
```
**uniq：**
```
uniq [-ic]
[参数]
-i ：忽略大小写的不同
-c ：进行计数　　　　
```
例：`last | cut -d ' ' -f 1 | sort | uniq -c`
![4](/assets/4_d4ypyp4xa.png)

**wc：**　

	wc [-lwm]
	[参数]
	-l ：仅列出行
	-w ：仅列出多少字(英文单字)
	-m ：多少字符　　
**例：**
`cat /etc/passwd | wc -l`：查看etc/passwd里面的账户数目

`last | grep [a-zA-Z] | grep -v "wtmp" | wc -l`：计算最近登录系统的人次。注意，‘wtmp’表示who temp，即一个数据库日志文件。

`cat /etc/passwd | wc`：查看/etc/passwd文件的行数，字数，字符数
![5](/assets/5_gekc6a9i1.png)
　　　　　　　　　
####4). 双向重定向命令tee：
<font color=#458967>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</font>　
![2](/assets/2_m5xek70nd.webp)
```
tee [-a] file1 file2 ...
[参数]
-a : 以累加的方式，将数据加入file中
`last | tee info | cut -d ' ' -f 1`：查询最近用户登录情况，并将其保存到文件中，同时在屏幕上输出切分后的第一部分信息。
```
**注意：**
如果tee后接的文件不存在，会创建该文件并写入；若已存在，内容会被覆盖掉，加上 -a参数则会累加。

####5). 字符转换命令：tr,col,join,paste,expand：
**tr：**用来删除一段信息当中的文字，或者进行文字信息的替换
```
tr [-cds] [“string1_to_translate_from”][“string2_to_translate_to”] < input-file
-c 用字符串1中字符集的补集替换此字符集，要求字符集为ASCII。
-d 删除字符串1中所有输入字符。
-s 删除指定的字符串中所有出现的字母，在输入文件中将重复出现的字符序列压缩为一个字符。
input-file是要转换的文件名。虽然可以使用其他格式输入，但这种格式最常用
```
![6](/assets/6_82apfygip.png)

**col：**col经常被用于将man page转存为纯文本文件
```
col [-xb]
[参数]
-x ： 将tab键换成对等的空格键
-b : 在文字内有反斜杠(/)时，仅保留反斜杠最后接的那个字符
```
**join：**　
```
join [-ti12] file1 file2
[参数]
-t : join 默认以空格符分隔数据，并且对比第一个字段的数据 ,如果两个文件相同，则将两条数据连成一行
-i : 忽略大小写的差异
-1 : 说明第一个文件通过那个字段来进行分析
-2 : 说明第二个文件通过那个字段来分析
```
**例：**将etc/passwd 按：分隔的第4个字段 与 etc/group的第3个字段 比较，如果相同，则将他两同行数据放在一起。

`join -t ':' -1 4 /etc/passwd -2 3 /etc/group`
![7](/assets/7_rbe3aat2v.png)

**past：**<font color=#9856>直接将两个文件两行贴在一起，两个文件的内容之间以[tab]键隔开。</font>
```
paste [-d] file1 file2
[ 参数]
-d : 后面可以接分隔字符，默认以[tab]来分隔的
- : 如果file部分写成-，表示接受standard input数据的意思
```

`cat no1.txt no2.txt | paste`：将两个文件的内容以`stdin`方式传递给paste，复制的时候进行了换行。
![8](/assets/8_2ay7rd03c.png)
`cat no1.txt no2.txt | paste  > 1.txt`：将paste输出到屏幕上的结果保存在文件中。

`cat no1.txt no2.txt | paste - -`：这里的合并方式是以`tab`键为分隔。
![9](/assets/9_qa9e0dbx0.png)

**expand**：把tab键转为空格键
```
expand [-t] file
[参数]
 -t : 后面接数字。一般，一个tab可以用8个空格代替，可以自行定义代表几个空格
```
####6). 切割命令split：将一个大文件依据指定大小切分成数个小文件。

	split [-bl] file prefix
	[参数]
	-b : 后面可接欲切割文件的大小，可加单位，例如b,k,m等
	-l : 以行数来进行切割
	PREFIX : 代表前导符，可作为切割文件的前导文字

###9.linux last命令：
1). last作用是显示近期用户或终端的登录情况。通过last命令查看该程序的log，管理员可以获知谁曾经或者企图连接系统。
2). 执行last命令时，它会读取/var/log目录下名称为wtmp的文件，并把该文件记录的登录系统或终端的用户名单全部显示出来。默认显示wtmp的记录，btmp能显示的更详细，可以显示远程登录，例如ssh登录。　　　　　　

###10. 关于linux的文件描述符使用：
<font color=#7539>1). 文件描述符（file descriptor）通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。**当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。**
2). 每个进程在PCB（Process Control Block）中保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针。</font>
![10](/assets/10_nnzae0wu3.png)
| 文件描述符 | 通道名 | 描述 | 默认设备 | 用途 |
|:----:|:-----:|:----:|:----:|:----:|
| 0 | STDIN | 标准输入 | 键盘 | read only |
| 1 | STDOUT | 标准输出 | 显示器 | write only |
| 2 | STDERR | 标准错误输出 | 显示器 | write only |
| 3及以上 | Filename | 其他文件 | 自己指定 | read and/or write |

<font color=#2365>Linux系统将所有设备都当作文件来处理，**而Linux用文件描述符来标识每个文件对象。**其实我们可以想象我们电脑的显示器和键盘在Linux系统中都被看作是文件，而它们都有相应的文件描述符与之对应。</font>

**<font color=red>补充：</font>**
**1.linux中`>>`，`>`，`<`的使用区别：**
1). 输入输出的区别：

	>>和>都属于输出重定向，<属于输入重定向。
2). 文件内容的区别：

	>会覆盖目标的原有内容。当文件存在时会先删除原文件，再重新创建文件，然后把内容写入该文件；否则直接创建文件。

	>>会在目标原有内容后追加内容。当文件存在时直接在文件末尾进行内容追加，不会删除原文件；否则直接创建文件

**2. linux文件描述符在`<`,`>`左右的时候如何使用：**
linux的文件描述符均用数字表示，当在左侧的时候直接表示对应的文件描述符合，但是在右侧时需要加上`&`，表示这是一个文件描述符而不是文件名。(注意，文件描述符均要和`<,>`紧贴)


##文件描述符常常用于文件重定向：
`exec 1> xlinsist`：将标准输出的位置修改到xlinsist文件中（注意，只在当前shell窗口中有效）
这回如果输入ls -al 或者ps命令，终端将不会显示任何东西。现在，我们可以新开一个终端查看xlinsist这个文件中是否有上面两个命令所显示的内容。注意：你必须新开一个终端。
####修改标准输入的位置：
![11](/assets/11_oro9tq3fe.png)
**这里从键盘把xlinsist读入到user变量。这个read需要键盘输入。现在，改变标准输入的默认位置：**
![12](/assets/12_1i1hishq1.png)
在这里，把当前的标准输入重定向到test文件中
####修改标准输出的位置：
将标准输出1的位置修改到了指向文件test：
![13](/assets/13_ylz8r5p8b.png)
标准错误输出符2和标准输出符1的区别是：它在命令出错情况下的输出。这没有什么太大的不同，我们也可以把它的输出修改到任何我们想要的位置。只不过我们需要把上面标准输出的1改成2，命令如下：

`exec 2> xlinsist`

####其他文件描述符：
除了0， 1，2以外，我们可以分配自己的文件描述符：
![14](/assets/14_j2kranx54.png)　
首先把文件描述符6指向test文件，(因为不像描述符1，所有的输出都会自然找它)然后看它是定向到显示器还是某个文件。所以当我们想找描述符6的时候我们要用&来引用它。在上面，echo输出的时候默认是
输出到文件描述符1,即标准输出上；我们将其改为指向了自定义的文件描述符6。所以echo的输出到了test文件中。

**注意：**
<font color=red>其实我们可以把文件描述符想像成一个文件的引用，它可以指向任何一个文件（包括显示器），指向的过程就是我们修改默认引用位置的过程。而用&符号来找到它指向的目标文件，从而向其写入数据。</font>

**一个小例子：**　
![15](/assets/15_40z9ucm15.png)
打开另一个窗口，查看test文件中的信息：
![16](/assets/16_877q8zzsm.png)
**具体流程：**
1). 首先文件描述符1默认指向的是显示器，用&来找到文件描述符1指向的目标文件，也就是显示器。因此文件描述符3也指向了显示器。然后，我们修改了文件描述符1指向的文件到test文件。
2). 接着两个echo命令的输出会自然去找文件描述符1，然后它看到文件描述符1指向的是test文件，所以它会把输出写到test文件中。
3). 最后，我们用&来找到文件描述符3指向的目标文件，也就是显示器，然后我们修改了文件描述符1指向的文件到显示器。因此，最后一个echo命令会自然的找文件描述符1然后输出到显示器上。

###11. less和more命令：
####less：
less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。

**用法：**`less 参数 文件`

####more：
Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能
（与 vi 相似），使用中的说明文件，请按 h 。

`more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]`
```
-num 一次显示的行数
-d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声
-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能
-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）
-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容
-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料
-s 当遇到有连续两行以上的空白行，就代换为一行的空白行
-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）
+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示
+num 从第 num 行开始显示
fileNames 欲显示内容的文档，可为复数个数
```
###12. linux下exec和sourch命令的区别以及使用
**相同点：**
在linux下source和exec都是bash内部命令。

**区别：**
1). `source命令`：
即`.`命令，是在当前shell进程中执行参数文件中的各个命令，而不是另起子进程(或sub-shell)，执行完成后把状态返回给当前的shell。

2). `exec命令`：
exec执行时会关闭当前shell进程，并且fork一个相同pid的shell进程来执行，系统调用新的exec的进程来替代原来的进程执行。没有新的进程创建，原来进程的代码段、数据段、堆栈都被新的process所代替。
比如在一个shell里执行`exec ls`，那么在列出当前目录后，这个shell就退出。因为这个shell进程已被替换为仅仅执行ls命令的一个进程，所以列出目录后`ls`进程执行结束，`shell`自然也就退出了。

3). exec文件重定向：
`exec 文件描述符>文件 / &文件描述符` 这里的&表示对一个文件描述符的引用，而不是指一个文件。


**补充：**
1). bash shell的命令分为两类：外部命令和内部命令。外部命令是通过系统调用或独立的程序实现的，如sed、awk等等。内部命令是由特殊的文件格式(.def)所实现，如cd、history、exec等等。

2). linux中fork的概念：

[a]. fork是linux的系统调用，用来创建子进程（child process）。子进程是父进程(parent process)的一个副本，从父进程那里获得一定的资源分配以及继承父进程的环境。子进程与父进程唯一不同的地方
在于pid（process id）。

[b]. 环境变量（传给子进程的变量，遗传性是本地变量和环境变量的根本区别）只能单向从父进程传给子进程。不管子进程的环境变量如何变化，都不会影响父进程的环境变量。

3). shell script：

[a]. 有两种方法执行shell scripts，一种是新产生一个shell，然后执行相应的shell scripts；一种是在当前shell下执行，不再启用其他shell。

<font color=#123598>[b]. 新产生一个shell然后再执行scripts的方法是在scripts文件开头加入以下语句`#!/bin/sh`，一般的script文件(*.sh)即是这种用法。这种方法先启用新的sub-shell（新的子进程）,然后在其下执行命令。</font>

<font color=#569843>[c]. 另外一种方法就是上面说过的source命令，不再产生新的shell，而在当前shell下执行一切命令。</font>

###13. linux lsof命令：

###14. mktemp命令：

　　　　
