[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

**示例 1：**

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

**示例 2：**

输入：nums = [1]
输出：1

**示例 3：**

输入：nums = [5,4,-1,7,8]
输出：23

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

解题思路：

1）动态规划

使用一个数组pre表示以当前位置结尾的子数组中最大和的值，pre[i] 表示结尾位置为i时，连续子数组的最大和。那么对于位置 i+1 :
pre[i + 1] = max (pre[i] + nums[i + 1], nums[i + 1]).

之后从pre数组中找出最大值就可以了

```
class Solution {

public:

    int maxSubArray(vector<int>& nums) {

        vector<int> pre = vector<int>(nums.size());

        int res = 0;

  

        if (nums.size() == 1)

            return nums[0];

  

        pre[0] = nums[0];

        res = pre[0];

  

        for (int i = 1; i < nums.size(); i++) {

            pre[i] = max(pre[i - 1] + nums[i], nums[i]);

            res = max(pre[i], res);

        }

        return res;

    }

};
```

2）分治

**这个分治方法类似于「线段树求解最长公共上升子序列问题」的 `pushUp` 操作。**

我们定义一个操作 get(a, l, r) 表示查询 a 序列 [l,r] 区间内的最大子段和，那么最终我们要求的答案就是 get(nums, 0, nums.size() - 1)。如何分治实现这个操作呢？

对于一个区间 [l,r]，我们取 $m=\lfloor \frac{l+r}{2} \rfloor$，对区间 [l,m] 和 [m+1,r] 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。这个时候我们考虑如何通过 [l,m] 区间的信息和 [m+1,r] 区间的信息合并成区间 [l,r] 的信息。最关键的两个问题是：

- 我们要维护区间的哪些信息呢？
- 我们如何合并这些信息呢？

对于一个区间 [l,r]，我们可以维护四个量：
- lSum 表示 [i,r] 内以 l 为左端点的最大子段和
- rSum 表示 [l,r] 内以 r 为右端点的最大子段和
- mSum 表示 [l,r] 内的最大子段和
- iSum 表示 [l,r] 的区间和

以下简称 [l,m] 为 [l,r] 的「左子区间」，[m+1,r] 为 [l,r] 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 [l,r] 的信息）？对于长度为 1 的区间 [i,i]，四个量的值都和 nums[i] 相等。对于长度大于 1 的区间：

- 首先最好维护的是 iSum，区间 [l,r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的 iSum。

- 对于 [l,r] 的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」 的 iSum +「右子区间」的 lSum，二者取最大值。

- 对于 [l,r] 的 rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取最大值。

- 当计算好上面的三个量之后，就很好计算 [l,r] 的 mSum 了。我们可以考虑 [l,r] 的 mSum 对应的区间是否跨越 m。它可能不跨越 m，也就是说 [l,r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 m，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。

```
class Solution1 {

public:

  

    // 保存每个区间内的四个状态信息

    struct Status {

        int lSum, rSum, mSum, iSum;

    };

  

    // 合并两个子区间，获取两个子区间的四个状态值

    Status pushUp(Status l, Status r) {

        int iSum = l.iSum + r.iSum;

        int lSum = max(l.lSum, l.iSum + r.lSum);

        int rSum = max(r.rSum, r.iSum + l.rSum);

  

        // 区分整个区间内的子段和，分为不跨越区间以及跨越区间两种情况，取二者中的最大值

        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);

  

        return (Status) {lSum, rSum, mSum, iSum};

    };

  

    Status get(vector<int> &a, int l, int r) {

  

        // 边界条件返回

        if (l == r) {

            return (Status){a[l], a[l], a[l], a[l]};

        }

  

        int m = (l + r) / 2;

  

        Status lsub = get(a, l, m);

        Status rsub = get(a, m + 1, r);

  

        return pushUp(lsub, rsub);

    }

  
  

    int maxSubArray(vector<int>& nums) {    

        return get(nums, 0, nums.size() - 1).mSum;

    }

};
```


[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 _一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间_ 。

**示例 1：**

输入：intervals = [ [1,3], [2,6] , [8,10] , [15,18] ]
输出：[ [1,6],[8,10],[15,18] ]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

**示例 2：**

输入：intervals = [ [1,4],[4,5] ]
输出：[ [1,5] ]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

**示例 3：**

输入：intervals = [ [4,7],[1,4] ]
输出：[ [1,7] ]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。

**提示：**

- 1 <= intervals.length <= 10^4
- intervals[i].length == 2`
- 0 <= starti <= endi <= 10^4

解题思路：
首先将数组中的所有区间按照区间的左端点排序，在排完序的列表中，可以合并的区间一定是连续的。

我们使用merged数组存放最终答案。从前向后遍历区间列表，并考虑每个区间：
- 如果当前区间的左端点在数组merged的最后一个区间的右端点之后，那么他们不会重合，此时可以将此区间添加进入merged数组中
- 否则，他们存在重合区间，重置merged中最后一个区间的右端点，设置为二者中的最大值

```
class Solution {

public:

    vector<vector<int>> merge(vector<vector<int>>& intervals) {

        vector<vector<int>> res;

        vector<int> tmp_interval;

  

        if (intervals.empty())

            return res;

  

        // 先将数组排序

        sort(intervals.begin(), intervals.end());

  

        res.emplace_back(intervals[0]);

  

        for (int i = 1; i < intervals.size(); i++) {

  

            tmp_interval = res[res.size() - 1];

  

            // 当前区间的左端点大于res结尾区间的右边界，说明两个区间不存在交集，可以将其添加到res中

            if (intervals[i][0] > tmp_interval[1])

            {

                res.push_back(intervals[i]);

            }

            else

            {

                // 合并区间，res结尾区间的右边界为二者最大值

                res[res.size() - 1][1] = max(tmp_interval[1], intervals[i][1]);

            }

        }

  

        return res;

    }

};
```


[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

输入: nums = [1,2,3,4,5,6,7], k = 3

输出: `[5,6,7,1,2,3,4]`

解释:

向右轮转 1 步: `[7,1,2,3,4,5,6]`
向右轮转 2 步: `[6,7,1,2,3,4,5]`
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

输入：nums = [-1,-100,3,99], k = 2

输出：[3,99,-1,-100]

解释: 

向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]

**提示：**

- 1 <= nums.length <= 10^5
- 2^(31) <= nums[i] <= 2^(31) - 1
- 0 <= k <= 10^5

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。
- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

解题思路：
1）最容易也是最简单的就是使用额外的数组

```
// 使用额外数组，时间和空间复杂度均为O(N)

class Solution {

public:

  void rotate(vector<int>& nums, int k) {

    int n = nums.size();

    vector<int> tmparr(n);

    for (int i = 0; i < n; i++) {

      tmparr[(i + k) % n] = nums[i];

    }

  

    nums.assign(tmparr.begin(), tmparr.end());

  }

};
```


2）环状替换
从前向后，将此元素与需要被替换的元素进行交换。使用临时变量保存被替换的元素，避免额外的数组开销。

从位置 0 开始，最初令 temp=nums[0]。根据规则，位置 0 的元素会放至 (0+k)mod(n)的位置，令 x=(0+k)mod(n)，此时交换 temp 和 nums[x]，完成位置 x 的更新。然后，我们考察位置 x，并交换 temp 和 nums[(x+k)mod(n)]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。

容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从 0 开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？

由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素，因为步长为k，因此 an=bk。即 an 一定为 n,k 的公倍数。

又因为我们在第一次回到起点时就结束，因此 a 要尽可能小，故 an 就是 n 和 k 的最小公倍数 lcm(n,k)，因此 b 就为 lcm(n,k)/k。

这说明单次遍历会访问到 lcm(n,k)/k 个元素。为了访问到所有的元素，我们需要进行遍历的次数为：

$\frac{n}{lcm(n, k) / k} = \frac{nk}{lcm(n, k)} = gcd(n, k)$


我们用下面的例子更具体地说明这个过程：

```
nums = [1, 2, 3, 4, 5, 6]
k = 2
```
![[Pasted image 20260102162835.png]]

```
class Solution {

public:

  void rotate(vector<int>& nums, int k) {

    int n = nums.size();

    k = k % n;

    // 求最大公约数

    int count = __gcd(k, n);

  

    // 遍历count次即可访问所有元素

    for (int start = 0; start < count; start++) {

  

      int current = start;

      int prev = nums[start];

  

      do {

        int next = (current + k) % n;

  

        swap(nums[next], prev);

        current = next;

  

      } while (current != start);

    }

  }

};
```

3）数组翻转
当我们将数组的元素向右移动 k 次后，**尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。**

该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k mod n 个元素就被移至数组头部，然后我们再翻转 [0, k mod n−1] 区间的元素和 [k mod n, n−1] 区间的元素即能得到最后的答案。


```
class Solution3 {

public:

    void reverse(vector<int>& nums, int start, int end) {

        while (start < end) {

            swap(nums[start], nums[end]);

            start += 1;

            end -= 1;

        }

    }

  

    void rotate(vector<int>& nums, int k) {

        k %= nums.size();

  

        // 先将整体翻转

        reverse(nums, 0, nums.size() - 1);

  

        // 接着依次翻转前k个以及后续的 n-k 个元素

        reverse(nums, 0, k - 1);

        reverse(nums, k, nums.size() - 1);

    }

};
```


[238. 除了自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的 全部前缀元素 和 后缀的乘积 都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 O(n) 时间复杂度内完成此题。

**示例 1:**

输入: nums = `[1,2,3,4]`
输出: `[24,12,8,6]`

**示例 2:**

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]

**提示：**

- 2 <= nums.length <= 10^5
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在  **32 位** 整数范围内

**进阶：** 你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）


解题思路：
如果可以使用除法就可以先获取整个数组的积，然后直接使用除法，但是这里做了限制，所以我们只能使用空间换时间。我们使用两个数组arr1，arr2，分别表示从头开始相乘，到当前位置的乘积，以及从后开始相乘，到当前位置前一个位置的乘积。对于位置 i，其结果就是arr1[i] * arr2[i]。








