[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 m * n 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用原地算法。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

**输入：** matrix = [ [1,1,1],[1,0,1],[1,1,1] ]
**输出：** [ [1,0,1],[0,0,0],[1,0,1] ]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

**输入：** matrix = [ [0,1,2,0],[3,4,5,2],[1,3,1,5] ]
**输出：** [ [0,0,0,0],[0,4,5,0],[0,3,1,0] ]

**提示：**

- m == matrix.length
- n == matrix[0].length
- 1 <= m, n <= 200
- $- 2^{31} \leq \\matrix[i][j] \leq 2^{31} - 1$
 
**进阶：**

- 一个直观的解决方案是使用  `O(mn)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(m + n)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

解题思路：
1）使用行数组以及列数组，分别表示每行以及每列是否存在 0。先遍历整个矩阵，如果 $matrix[i][j]$为 0，表示 i 行存在 0，j 列存在 0。

```
class Solution {

public:

void setZeroes(vector<vector<int>>& matrix) {

int n = matrix.size();

int m = matrix[0].size();

vector<int> rows(n);

vector<int> cols(m);

  

for (int i = 0; i < n; i++) {

for (int j = 0; j < m; j++) {

if (matrix[i][j] == 0) {

rows[i] = true;

cols[j] = true;

}

}

}

  

for (int i = 0; i < n; i++) {

for (int j = 0; j < m; j++) {

if (rows[i] || cols[j])

matrix[i][j] = 0;

}

}

}

};
```


2）进一步，可以使用第一行和第一列保存内部矩阵中 0 值的位置信息。
- 首先使用两个临时变量分别保存第一行和第一列中是否存在 0；
- 之后使用内部矩阵设置第一行和第一列的 0 信息（其实就是将 【i，j】位置的 0 分别设置到第一行和第一列的对应位置上，结果是等价的）
- 之后根据第一行和第一列的 0 信息设置内部矩阵
- 设置完内部矩阵后再根据之前保存的临时变量设置第一行以及第一列

```
class Solution1 {

public:

void setZeroes(vector<vector<int>>& matrix) {

int n = matrix.size(); // 行数

int m = matrix[0].size(); // 列数

  

int flag_col0 = false, flag_row0 = false;

  

// 判读第一行是否存在0

for (int i = 0; i < m; i++) {

if (!matrix[0][i]) {

flag_row0 = true;

}

}

  

//判断第一列是否存在 0

for (int i = 0; i < n; i++) {

if (!matrix[i][0]) {

flag_col0 = true;

}

}

  

// 用（1～n-1）（1～m-1）的行列数据设置第一行信息

// 等价变换，将(i,j)位置表示的 0 信息分别设置到(i,0) 和 (0,j)

for (int i = 1; i < n; i++) {

for (int j = 1; j < m; j++) {

if (!matrix[i][j]) {

matrix[i][0] = 0;

matrix[0][j] = 0;

}

}

}

  

// 根据等价变换后的第一行和第一列的 0 信息，重置内部矩阵

for (int i = 1; i < n; i++) {

for (int j = 1; j < m; j++) {

if (!matrix[i][0] || !matrix[0][j]) {

matrix[i][j] = 0;

}

}

}

  

// 最后根据临时变量设置第一行和第一列的相关信息

if (flag_row0) {

for (int i = 0; i < m; i++) {

matrix[0][i] = 0;

}

}

if (flag_col0) {

for (int i = 0; i < n; i++) {

matrix[i][0] = 0;

}

}

}

};
```


[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

**输入：** matrix = [ [1,2,3],[4,5,6],[7,8,9] ]
**输出：** [1,2,3,6,9,8,7,4,5]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

**输入：**matrix = [ [1,2,3,4],[5,6,7,8],[9,10,11,12] ]
**输出：** [1,2,3,4,8,12,11,10,9,5,6,7]

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

**解题思路：**
1）模拟螺旋矩阵的路径，初始位置是矩阵的左上角，当路径超过界限或者进入之前访问过的位置时，顺时针旋转并进入下一个方向。

使用一个辅助矩阵来判断路径是否进入之前被访问过的位置，当路径访问到一个位置后就将辅助矩阵中对应的位置设置为已访问的状态。

因为矩阵中的每个元素都仅会被访问一次，所以路径的长度就是矩阵中元素的数量。











