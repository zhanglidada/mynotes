[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 m * n 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用原地算法。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

**输入：** matrix = [ [1,1,1],[1,0,1],[1,1,1] ]
**输出：** [ [1,0,1],[0,0,0],[1,0,1] ]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

**输入：** matrix = [ [0,1,2,0],[3,4,5,2],[1,3,1,5] ]
**输出：** [ [0,0,0,0],[0,4,5,0],[0,3,1,0] ]

**提示：**

- m == matrix.length
- n == matrix[0].length
- 1 <= m, n <= 200
- $- 2^{31} \leq \\matrix[i][j] \leq 2^{31} - 1$
 
**进阶：**

- 一个直观的解决方案是使用  `O(mn)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(m + n)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？

解题思路：
1）使用行数组以及列数组，分别表示每行以及每列是否存在 0。先遍历整个矩阵，如果 $matrix[i][j]$为 0，表示 i 行存在 0，j 列存在 0。

```
class Solution {

public:

void setZeroes(vector<vector<int>>& matrix) {

int n = matrix.size();

int m = matrix[0].size();

vector<int> rows(n);

vector<int> cols(m);

  

for (int i = 0; i < n; i++) {

for (int j = 0; j < m; j++) {

if (matrix[i][j] == 0) {

rows[i] = true;

cols[j] = true;

}

}

}

  

for (int i = 0; i < n; i++) {

for (int j = 0; j < m; j++) {

if (rows[i] || cols[j])

matrix[i][j] = 0;

}

}

}

};
```


2）进一步，可以使用第一行和第一列保存内部矩阵中 0 值的位置信息。
- 首先使用两个临时变量分别保存第一行和第一列中是否存在 0；
- 之后使用内部矩阵设置第一行和第一列的 0 信息（其实就是将 【i，j】位置的 0 分别设置到第一行和第一列的对应位置上，结果是等价的）
- 之后根据第一行和第一列的 0 信息设置内部矩阵
- 设置完内部矩阵后再根据之前保存的临时变量设置第一行以及第一列

```
class Solution1 {

public:

void setZeroes(vector<vector<int>>& matrix) {

int n = matrix.size(); // 行数

int m = matrix[0].size(); // 列数

  

int flag_col0 = false, flag_row0 = false;

  

// 判读第一行是否存在0

for (int i = 0; i < m; i++) {

if (!matrix[0][i]) {

flag_row0 = true;

}

}

  

//判断第一列是否存在 0

for (int i = 0; i < n; i++) {

if (!matrix[i][0]) {

flag_col0 = true;

}

}

  

// 用（1～n-1）（1～m-1）的行列数据设置第一行信息

// 等价变换，将(i,j)位置表示的 0 信息分别设置到(i,0) 和 (0,j)

for (int i = 1; i < n; i++) {

for (int j = 1; j < m; j++) {

if (!matrix[i][j]) {

matrix[i][0] = 0;

matrix[0][j] = 0;

}

}

}

  

// 根据等价变换后的第一行和第一列的 0 信息，重置内部矩阵

for (int i = 1; i < n; i++) {

for (int j = 1; j < m; j++) {

if (!matrix[i][0] || !matrix[0][j]) {

matrix[i][j] = 0;

}

}

}

  

// 最后根据临时变量设置第一行和第一列的相关信息

if (flag_row0) {

for (int i = 0; i < m; i++) {

matrix[0][i] = 0;

}

}

if (flag_col0) {

for (int i = 0; i < n; i++) {

matrix[i][0] = 0;

}

}

}

};
```


[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

**输入：** matrix = [ [1,2,3],[4,5,6],[7,8,9] ]
**输出：** [1,2,3,6,9,8,7,4,5]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

**输入：**matrix = [ [1,2,3,4],[5,6,7,8],[9,10,11,12] ]
**输出：** [1,2,3,4,8,12,11,10,9,5,6,7]

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 10`
- `-100 <= matrix[i][j] <= 100`

**解题思路：**
1）模拟螺旋矩阵的路径，初始位置是矩阵的左上角，当路径超过界限或者进入之前访问过的位置时，顺时针旋转并进入下一个方向。

使用一个辅助矩阵来判断路径是否进入之前被访问过的位置，当路径访问到一个位置后就将辅助矩阵中对应的位置设置为已访问的状态。

因为矩阵中的每个元素都仅会被访问一次，所以路径的长度就是矩阵中元素的数量。


```
// 使用一个辅助矩阵存放路径访问过的信息

class Solution {

  public:

    vector<int> spiralOrder(vector<vector<int>>& matrix) {

      int m = matrix.size();

      int n = matrix[0].size();

      int total = m * n;

      vector<int> res(total);

      vector<vector<int>> visited(m, vector<int>(n, 0));  // 使用访问数组登记路径是否被访问过

      int posx = 0, posy = 0;

      int directionIndex = 0;

  

      // 总共也只需要访问total个元素

      for (int i = 0; i < total; i++) {

        res[i] = matrix[posx][posy];

        visited[posx][posy] = true;

  

        // 获取顺时针访问的下一个位置

        int nextx = posx + directions[directionIndex][0];

        int nexty = posy + directions[directionIndex][1];

  

        // 访问到了边界，开始变换方向

        if (nextx < 0 || nextx >= m || nexty < 0 || nexty >= n || visited[nextx][nexty])

          directionIndex = (directionIndex + 1) % 4;

  

        posx += directions[directionIndex][0];

        posy += directions[directionIndex][1];

      }

      return res;

    }

  

  /*

   第一列表示行的移动方向，第二列表示列的移动方向

   因为是顺时针，所以行的轨迹为：不变 -> 增加 -> 不变 -> 减少

   列的轨迹为 ：增加 -> 不变 -> 减少 -> 不变

  */

  int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

};
```


2）使用四个边界点，依次遍历矩阵中的元素，遍历完一圈后将边界缩小


```
// 将矩阵从内到外分为多层，先输出外层再输出内层

class Solution1 {

  public:

    vector<int> spiralOrder(vector<vector<int>>& matrix) {

      int rows = matrix.size();

      int cols = matrix[0].size();

      int left = 0;             // 定义遍历的起始边界点

      int right = cols - 1;

      int top = 0;

      int bottom = rows - 1;

      vector<int> order;

  

      // left == right 以及 top == bottom的时候遍历最后一次： 向右，向下

      while (left <= right && top <= bottom) {

        // 向右遍历

        for (int column = left; column <= right; column ++) {

          order.push_back(matrix[top][column]);

        }

  

        // 向下遍历

        for (int row = top + 1; row <= bottom; row++) {

          order.push_back(matrix[row][right]);

        }

  

        // 还未遍历到结尾

        if (left < right && top < bottom) {

          // 向左边历

          for (int column = right -1; column > left; column --) {

            order.push_back(matrix[bottom][column]);

          }

  

          // 向上遍历

          for (int row = bottom; row > top; row --) {

            order.push_back(matrix[row][left]);

          }

        }

  

        left ++;

        right --;

        top ++;

        bottom--;

      }

  

      return order;

    }

};

```


[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

给定一个 _n_ × _n_ 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

**输入：** matrix = [ [1,2,3],[4,5,6],[7,8,9] ]
**输出：** [ [7,4,1],[8,5,2],[9,6,3] ]

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

**输入：** matrix = [ [5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16] ]
**输出：** [ [15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11] ]

**提示：**

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`




