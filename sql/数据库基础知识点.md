#数据库期末复习总结
##第一章 绪论
###1.1 数据库系统概述
####1.1.1 数据库管理系统(DBMS)的功能:
1) 数据定义功能
2) 数据组织、存储和管理
3) 数据库操纵功能
4) 数据库的事务和运行功能
5) 数据库的建立和维护功能
6) 其他功能
####1.1.2 数据库管理技术经历的三个阶段
1) 人工管理阶段
2) 文件系统阶段
3) 数据库系统阶段
####1.1.3 数据独立性
1) 物理独立性:是指用户的应用程序与数据库中数据的物理存储是相互独立的。
2) 逻辑独立性:是指用户的应用程序与数据库的逻辑结构是相互独立的。
3) 数据独立性是由数据库管理系统提供的二级映像功能来保证的。
>数据独立性是由DBMS的二级映像功能来保证的（外模式/模式映像，模式/内模式映
像），这两层映像机制保证了数据库系统中数据的逻辑独立性和物理独立性。

###1.2 数据模型
数据模型是数据库系统的**核心**和**基础**
####1.2.1 数据模型分类
1. 第一类：
概念模型：是现实到信息世界的第一层抽象,也是数据库设计人员和用户之间进行交流的
语言
2. 第二类:
+ 逻辑模型
  - 层次模型
  - 网状模型
  - 关系模型
  - ……

+ 物理模型:是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在
磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。

####1.2.2 概念模型
1. 信息世界中的基本概念
  - 实体:现实世界客观存在并可相互区别的事物称为实体。例如:学生,部门...
  - 属性:实体所具有的某一**特性**称为属性。例如:学生实体的学号,年龄...
  - 码:唯一标识实体的属性或属性集称为码。例如:学号为学生实体的码
  - 实体型:具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。例如，学生（学号，姓名，性别，出生年月，所在院系，入学时间）
  - 实体集:同一类型实体的集合称为实体集。例如，全体学生就是一个实体集。
  - 与关系模式表对应的关系:
    - 表:实体
    - 表的属性:属性
    - 表的码:码
    - 表的结构:实体集
    - 表的所有元组:实体集
  - 实体之间的关系:**一对一,一对多,多对多**
  - 概念模型的一种表示方法:E-R模型，全称是:实体-联系方法(Entity-Relationship approach)

2. 数据模型的组成:
  + 数据结构(组成对象与对象之间的联系)
  + 数据操作(CRUD)
  + 数据的完整性约束条件(实体完整性(主码),参照完整性(外码),用户自定义完整性)

3. 常用的数据模型
  + 层次模型:
    倒立的树
  + 网状模型:
    有向图,链表
  + 关系模型:
    - 二维表
    - 关系（relation）：一个关系对应一张表
    - 元组（tuple）：表中的一行即为一个元组。
    - 属性（attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名。
    - 域（domain）：域是一组具有相同数据类型的值的集合，属性的取值范围来自某个域。
    - 分量：**元组中**的一个属性值。
    - 关系模式：对关系的描述，一般表示为关系名（属性l，属性2.….属性n）
      - 例如:学生（学号，姓名，年龄，性别，系名，年级）
      - 关系模型要求关系必须是规范化的，必须达到第一范式(1NF)
      - 关系模型的优缺点:
        （1）关系模型与格式化模型不同，它是建立在严格的数学概念的基础上的。
        （2）关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。数据结构简单、清晰，用户易懂易用。
        （3）关系模型的存取路径对用户透明，具有更高的数据独立性、更好的安全保密性，简化数据库的开发工作。
  + 面向对象数据模型
    - 表格具有抽象意义

###1.3 数据库系统的结构
####1.3.1 数据库系统的三级模式结构
1. 模式(逻辑模式)
  - 逻辑模式中的这些表称为基表，与物理模式的表一一对应
2. 外模式(用户模式)
  - 模式的子集,给最终用户看到的数据的样子,视图
3. 内模式(存储模式) 描述了数据在磁盘上是如何存储的

>为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统（DBMS）在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。

###1.4 数据库系统的组成
1. 数据库管理员(DBA,DataBase Administrator)
+ 决定数据库中的信息内容和结构。
+ 决定数据库的存储结构和存取策略。
+ 定义数据的安全性要求和完整性约束条件。
+ 监控数据库的使用和运行。
+ 数据库的改进和重组、重构。
2. 数据库系统
+ 应用程序+DBMS+数据库+DBA（数据库管理员）


##第二章 关系数据库
###2.1 关系数据库
####2.1.1 关系
1. 域:一组具有相同数据类型的值的集合
2. 笛卡尔积:一个域中的元素与另外的域中的元素分别结合构成一个元组
3. 关系
1. 候选码:某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码
（candidate key）。
2. 主码:若一个关系有多个候选码，则选定其中一个为主码（primary key）。
3. 主属性和非主属性:候选码的诸属性称为主属性（prime attribute）。不包含在任何候选
码中的属性称为非主属性（non-prime attribute）或非码属性（non-key attribute）。
4. 全码:关系模式的所有属性是这个关系模式的候选码，称为全码（all-key）。
5. 关系的三种类型:
1. 基本关系(又称为基本表或基表):实际存在的表,是实际存储数据的表示,不可再分,必
须规范化(也就是达到第一范式1NF)
2. 查询表:查询结果对应的表
3. 视图表:由基本表或其他视图表导出的表,是虚表,不对应实际存储数据


2.2 关系操作
1. 关系操作
1. 查询
2. 插入
3. 删除
4. 修改
2. 基本查询操作:
选择操作σ (Select)(横挑）从一个表中把满足条件的元组选出来
选择是一种单目运算，即对一个关系施加的运算，按给定条件从关系中挑选满足条件的
元组组成的集合
语法格式：σ<选择条件>（<关系名>）
投影操作π (Project)(竖挑) 将需要的属性列出来
投影操作是单目运算，从关系中挑选指定的属性组成的新关系。
语法格式：π<属性表>（<关系名>）
笛卡尔乘积× :两个关系的拼接
集合差- 把属于关系A不属于关系B的元组找出来
并 ∪ 把两个模式相同的元组并起来
3. 其他操作可由基本操作来定义和导出

2.3 关系的完整性
1. 实体完整性原则(主码)
若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值（null value）。所谓
空值就是“不知道”或“不存在”或“无意义”的值。
2. 参照完整性原则(外码)
设F是基本关系R的一个或一组属性，但不是关系R的码，Ks，是基本关系S的主码。如果F与
Ks相对应，则称F是R的外码（foreign key），并称基本关系R为参照关系（referencing
relation），基本关系S为被参照关系（referenced relation）或目标关系（target
relation）。关系R和S不一定是不同的关系。

2.4 关系代数
1. 分类
1. 传统的集合运算(从行的角度进行,二目运算,两个关系之间进行)
1. 集合的并、交、差
参与集合的两个关系要满足两个条件:
1. 属性个数相同
2. 属性类型要一样
参与并、差操作的两个关系的元组必须限制为同类型的，即具有相同的目，且对应
的属性的域相同——并兼容（union compatibility）;
1. 关系操作优先级高于集合操作;
2. 一元操作（单目）优先级高于二元操作。
2. 笛卡尔积
1. 结果模式包括进行操作的两个表的所有属性，两张表的每条元组之间两两拼接
2. 若R和S中有相同的属性名，在这些属性名前加上关系名作为限定词(如：R.B,S.B)，
进行区别。
2. 专门的关系运算(涉及行又涉及列)
1. 选择操作σ (Select)(横挑）从一个表中把满足条件的元组选出来
选择是一种单目运算，即对一个关系施加的运算，按给定条件从关系中挑选满足条
件的元组组成的集合 。
语法格式：σ<选择条件>（<关系名>）
2. projection 投影操作π (Project)(竖挑) 将需要的属性列出来
投影操作是单目运算，从关系中挑选指定的属性组成的新关系。
语法格式：π<属性表>（<关系名>）
3. 连接
1. 语法格式R∞<连接条件>S＝σ<连接条件>（R * S）
解释:关系R和关系S在该条件的连接操作等于关系R和关系S先做笛卡尔乘积,
再按照该条件做选择操作
2. 等值连接:
一种特殊的条件连接，连接条件只有等值的条件
结果模式和笛卡尔乘积的模式类似，把等值的属性去掉一列
3. 自然连接:两张表在所有的公共属性上做等值连接
步骤：
1. 作R x S（笛卡儿积）
2. 在R x S上选择同名的属性组
3. 去掉重复属性
一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是同
时从行和列的角度进行运算。
4. 除运算
计算思路：比如对于A/B来说，我们要找在关系A中跟关系B中所有y值都有联系的x
值。【也就是找出在关系B中没有一个y值与A的是没有联系的。否定的否定,就是找
出B中的列的属性在A中都有关联的属性,B中列的属性不写.】
A/B: Πx(A)-all disqualified tuples(所有不合格的元组) = Πx((Πx(A)×B)-A)
先在A中找不满足除法条件的x
先把A做一个投影，投影到x属性
将投影结果和关系B做一个笛卡尔乘积
用笛卡尔乘积结果-A
对上一步结果做一个投影，投影到x
把关系A所有的x值减去所有不满足条件的x值
把关系A投影到x
投影结果减去上一操作找到的所有不满足条件的x值
语法格式:A/B = {<x>|ョ<x,y>∈A，∀<y>∈B}


##第三章 关系数据库标准语言 SQL
3.1 SQL 概述
1. SQL:结构化查询语言（Structured Query Language）
2. SQL的特点
1. 综合统一
2. 高度非过程化
关系代数是一种过程化的表达。
关系演算是一个非过程化的表达。只需要说明得到的结果，不必标明过程,是说明性语
言。
3. 面向集合的操作方式
4. 以同一种语法结构提供多种使用方式
5. 语言简洁,易学易用
3. SQL的基本概念
三级模式结构对应的关系：
外模式-->视图
视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中
只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表
中，因此视图是一个虚表。视图在概念上与基本表等同，用户可以在视图上再定义
视图。
模式-->基本表
基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本
表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在
存储文件中。
内模式-->存储文件
存储文件的逻辑结构组成了关系数据库的内模式，存储文件的物理结构对最终用户
是隐蔽的。
3.2 数据定义
1. 模式的定义与删除
1. 定义模式
CREATE SCHEMA<模式名>AUTHORIZATION<用户名>；
AUTHORIZATION:授权
2. 删除模式
DROP SCHEMA<模式名><CASCADE|RESTRICT>；
CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删
除；
RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象（如表、视
图等），则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执
行DROP SCHEMA语句。
2. 基本表的定义和删除与修改
1. 定义基本表
[例3.7]建立学生选课表SC。
2. 数据类型
1. CHAR(n):长度为n的定长字符串
2. VARCHAR(n):最大长度为n的变长字符串
3. DATE:年.月.日,YYYY-MM-DD
4. TIME:时.分.秒,HH:MM:SS
3. 模式与表
CREATE TABLE SC
（Sno CHAR（9）.
Cno CHAR（4）.
Grade SMALLINT，
PRIMARY KEY（Sno.Cno），/*主码由两个属性构成，必须作为表级完整性进行定义*/
FOREIGN KEY（SnO）REFERENCES Student（Sno），/*表级完整性约束条件，Sno是外码，
被参照表是Student*/
FOREIGN KEY（CnO）REFERENCES Course（Cno）/*表级完整性约束条件，Cno是外码，被
参照表是Course*/
);
1. 用户创建表没有指定模式,系统根据搜索路径来确定该对象所属的模式
2. 显示当前路径:search path
4. 修改表
1. add,用于增加新列,添加约束条件
[例3.8]向Student表增加“入学时间”列，其数据类型为日期型。
2. 修改数据类型:alter
[例3.9]将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。
5. 删除基本表
1. DROP TABLE<表名>[RESTRICTICASCADE]；
选择RESTRICT，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的
约束所引用（如CHECK，FOREIGNKEY等约束），不能有视图，不能有触发器
（trigger），不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不
能被删除。
选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖
对象，例如视图，都将被一起删除。
默认情况下是RESTRICT
3.3 索引的建立和删除
1. 建立索引的优点
建立索引是加快查询速度的有效手段。数据库索引类似于图书后面的索引，能快速定位到需
要查询的内容。用户可以根据应用环境的需要在基本表上建立一个或多个索引，以提供多种
存取路径，加快查找速度。
2. 建立索引
[例3.13]为学生-课程数据库中的Student、Course和SC三个表建立索引。其中Student表按
学号升序建唯一索引，Course表按课程号升序建唯一索引，SC表按学号升序和课程号降序建
唯一索引。
3. 修改索引
[例3.14]将SC表的SCno索引名改为SCSno。
4. 删除索引
[例3.15]删除Student表的Stusname索引。
ALTER TABLE Student ADD S_entrance DATE；
ALTER TABLE Student ALTER COLUMN Sage INT；
CREATE UNIQUE INDEX Stusno ON Student（Sno）；
CREATE UNIQUE INDEX Coucno ON Course（Cno）；
CREATE UNIQUE INDEX SCno ON SC（Sno ASC，Cno DESC）；
ALTER INDEX SCno RENAME TO SCSno；
3.4 数据查询
1. 单表查询
1. 选择表中的若干列,
[例3.16]查询全体学生的学号与姓名。
2. 选择表中的若干元组
消除取消重复的行,两个本来并不完全相同的元组在投影到指定的某些列上后，可能会变
成相同的行。可以用DISTINCT消除它们。
[例3.21]查询选修了课程的学生学号。
如果没有指定DISTINCT关键词，则默认为ALL，即保留结果表中取值重复的行。
[例3.22]查询计算机科学系全体学生的名单。
语句的执行过程
对表进行全表扫描,扫描每个元组,检查该元组在Sdept列的值是否等于'CS',如果相
等,则取出Sname,组成一个新元素输出,否则跳过该元素重复该过程
如果人多,可以在Sdept列上建立索引,系统会利用该索引找出Sdept='CS'元组,
从中取出Sname形成结果关系.
确定范围
BETWEEN AND
[例3.26]查询年龄不在20~23岁之间的学生姓名、系别和年龄。
确定集合:谓词IN可以用来查找指定集合的元组
[例3.27]查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和
性别。
字符匹配:LIKE
DROP INDEX Stusname；/*删除索引时，系统会同时从数据字典中删去有关该索引的描述。*/
SELECT Sno，Sname FROM Student；-- 将Student表投影到Sno,Sname上
SELECT DISTINCT Sno FROM SC;
SELECT Sno FROM SC；
等价于
SELECT ALL Sno FROM SC；
SELECT SnameFROM Student WHERE Sdept='CS'；
SELECT Sname，Sdept，Sage FROM Student WHERE Sage NOT
BETWEEN 20 AND 23；
SELECT Sname，Ssex FROM Student WHERE Sdept IN（'CS，；MA，
IS'）；
[NOT]LIKE<匹配串>[ESCAPE'<换码字符>]
% 表示任意长度的字符串
_表示任意单个字符串
如果用户要查询的字符串本身就含有通配符%或_，这时就要使用ESCAPE<换码字
符>短语对通配符进行转义了。
[例3.35]查询以“DB”开头，且倒数第三个字符为i的课程的详细情况。
涉空值的查询
[例3.37]查所有有成绩的学生学号和课程号。
多从条件的查询
AND的优先级高于OR,可以使用括号改变优先级
[例3.27]查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和
性别。
3. ORDER BY 子句
用户可以用ORDERBY子句对查询结果按照一个或多个属性列的升序（ASC）或降序
（DESC）排列，默认值为升序。
注: ASC = ascend, DESC = descend; 词根:-d 表示向下
[例3.39]查询选修了3号课程的学生的学号及其成绩，查询结果按分数的降序排列。
4. 聚集函数
指定了DISTINCT,需要去除重复值,不指定默认为ALL,不需要去除掉
[例3.45]查询学生201215012选修课程的总学分数。
SELECT* FROM Course WHERE Cname LIKE DB\_%i_'ESCAPE'\；
/*这里的匹配串为"DB\_%i__"第一个_前面有换码字符\，所以它被转义为普通的字
符。而i后面的两个的前面均没有换码字符\，所以它们仍作为通配符。*/
SELECT Sno，Cno FROM SC WHERE Grade IS NOT NULL；/*IS不能使用=代替
*/
SELECT Sname，Ssex FROM Student WHERE Sdept IN（"CS，MA'，IS）;
= /*IN谓词实际上是多个OR运算的缩写*/
SELECT Sname,Ssex FROM Student WHERE Sdept='CS'OR Sdept='MA'OR
Sdept='IS';
SELECT Sno，Grade FROM SC WHERE Cno='3' ORDER BY Grade DESC；
COUNT（*）统计元组个数
COUNT（[DISTINCT|ALL]<列名>）统计一列中值的个数
SUM（[DISTINCT|ALL]<列名>）计算一列值的总和（此列必须是数值型）
AVG（[DISTINCT|ALL]<列名>）计算一列值的平均值（此列必须是数值型）
MAX（[DISTINCT|ALL]<列名>）求一列值中的最大值
MIN（[DISTINCT|ALL]<列名>）求一列值中的最小值
注意:WHERE子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于SELECT子
句和GROUP BY中的HAVING子句。
5. GROUP BY 子句
GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。如果未对查询
结果分组，聚集函数将作用于整个查询结果。分组后聚集函数将作用于每一个组，即每
一组都有一个函数值。
[例3.46]求各个课程号及相应的选课人数。
如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组，则
可以使用HAVING短语指定筛选条件。
WHERE子句与HAVING短语的区别在于作用对象不同。WHERE子句作用于基本表或视
图，从中选择满足条件的元组。HAVING短语作用于组，从中选择满足条件的组。
[例3.48]查询平均成绩大于等于90分的学生学号和平均成绩。
2. 连接查询
一个查询同时涉及多个表
1. 等值连接与非等值连接
连接运算符为=
[例3.49]查询每个学生及其选修课程的情况。
SELECT SUM（Ccredit）
FROM SC，Course WHERE Sno'201215012'AND SC.Cno-Course.Cno；
-- 当聚集函数遇到空值时，除COUNT(*)外，都跳过空值而只处理非空值。COUNT（*）是
对元组进行计数，某个元组的一个或部分列取空值不影响COUNT的统计结果。
SELECT Cno，COUNT（Sno）
FROM SC GROUP BY Cno；
-- 该语句对查询结果按Cno的值分组，所有具有相同Cno值的元组为一组，然后对每一组作
用聚集函数COUNT进行计算，以求得该组的学生人数。
-- 下面的语句是不对的：
SELECT Sno，AVG（Grade）
FROM SC
WHERE AVG（Grade）>=90
GROUP BY Sno；
-- 因为WHERE子句中是不能用聚集函数作为条件表达式的，WHERE作用的是整个表,而聚集
函数是作用于组的.
-- 正确的查询语句应该是：
SELECT Sno，AVG（Grade）
FROM SC GROUP BY Sno
HAVING AVG（Grade）>=90；
-- WHERE和GROUP BY组合时,WHERE应该在前,因为它作用与整个表
-- HAVING和GROUP BY组合时,HAVING应该在后,因为只有先进行分组后HAVING才能使
用,它是作用域组的.
SELECT Student.*，SC.*
FROM Student，SC
WHERE Student.Sno=SC.Sno；
/*将Student与SC中同一学生的元组连接起来*/
2. 自身连接(p101)
表与自己的连接
3. 外连接
同关系代数中的概念一样,把悬浮元组(作连接的时候被舍弃的元组)仍然保存到结果关系
中.
左外连接:left outer join,保留左边关系中的悬浮元组
右外连接:right outer join,保留右边关系中的悬浮元组
4. 多表连接
两个表以上的表进行连接
3. 嵌套查询
在SQL语言中，一个SELECT-FROM-WHERE语句称为一个查询块。将一个查询块嵌套在另一
个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询（nested query）。
上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。
子查询的SELECT语句中不能使用ORDER BY子句，ORDER BY子句只能对最终查询结果排
序。
以层层嵌套的方式来构造程序正是SQL中“结构化”的含义所在。
1. 带有IN谓词的子查询
1. 不相关子查询:子查询的结果不依赖与父查询
[例3.56]查询选修了课程名为“信息系统”的学生学号和姓名。
本查询涉及学号、姓名和课程名三个属性。学号和姓名存放在Student表中，
课程名存放在Course表中，但Student与Course两个表之间没有直接联系，
必须通过SC表建立它们二者之间的联系。所以本查询实际上涉及三个关系。
2. 带有比较运算符的子查询(p106)
父查询与子查询之间用比较运算符进行连接.
相关子查询:子查询的查询条件依赖于父查询，整个查询语句称为相关嵌套查询
（correlated nested query）语句。
[例3.57]找出每个学生超过他自己选修课程平均成绩的课程号。
SELECT Sno，Sname -- ③最后在Student关系中取出Sno和Sname
FROM Student
WHERE Sno IN
(SELECT Sno -- ②然后在SC关系中找出选修了3号课程的学生a
学号
FROM SC
WHERE Cno IN
(SELECT Cno -- ①首先在Course关系中找出“信息系统”的课程
号，结果为3号 FROM Course
WHERE Cname='信息系统'
)
);
-- 用连接查询实现：
SELECT Student.Sno，Sname
FROM Student，SC，Course
WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND
Course.Cname='信息系统；
相关子查询由于子查询与父查询有关,必须反复求值,而不相关子查询由于子查询与父查
询无关,所以可以子查询可以一次求解出来
3.5 数据更新
1. 插入数据:INSERT
[例3.69]将一个新学生元组（学号：201215128，姓名：陈冬，性别：男，所在系：IS，年
龄：18岁）插入到Student表中。
2. 修改数据:UPDATE
[例3.73]将学生201215121的年龄改为22岁。
3. 删除数据
[例3.76]删除学号为201215128的学生记录。
3.6 空值的处理
1. 概念:
所谓空值就是“不知道”或“不存在”或“无意义”的值。空值是一个特殊的值,含有不确定性
2. 判断:
IS NULL 或 IS NOT NULL
3.7 视图
1. 概念:
视图是由一个或几个基本表(或视图)导出的表,是个虚表,基本表的数据改变了,数据库中只存放视图
的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。视图中的查询出来的数据
也随之改变,视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。视图处于
外模式
2. 定义视图
1. 视图建立在基本表上
[例3.84]建立信息系学生的视图。
SELECT Sno，Cno
FROM SC x
WHERE Grade >=(SELECT AVG(Grade) -- 某学生的平均成绩
FROM SC y
WHERE y.Sno = x.Sno);
INSERT INTO Student（Sno，Sname，Ssex，Sdept，Sage）
VALUES('201215128','陈冬','男','IS',18);
-- 字符串要用单引号引出来,如果这里Student后面没有指明属性名,values后面的属性值必须
与创建的表中的属性值对应.
UPDATE Student SET Sage=22
WHERE Sno='201215121';
DELETE FROM Student WHERE Sno = '201215128';
2. 视图建立在已经定义好的视图上
[例3.87]建立信息系选修了1号课程且成绩在90分以上的学生的视图。
3. 删除视图
1. 格式:DROP VIEW<视图名>[CASCADE]；
2. 删除视图的时候,如果该视图上还导出了其他的视图,那么不能删除,需要在后面加CASCADE,即
级联操作,进而把该视图和它导出的所有视图删除.
[例3.91]删除视图BT_S和视图IS_S1：
4. 查询视图
1. 视图消解:(p124)从数据字典中取出视图的定义，把定义中的子查询和户的查询结合起来，转
换成等价的对基本表的查询，然后再执行修正了的查询。这一转发过程称为视图消解（view
resolution）。
[例3.92]在信息系学生的视图中找出年龄小于20岁的学生。
CREATE VIEW IS_Student
AS
SELECT Sno，Sname，Sage
FROM Student
WHERE Sdept=IS;
-- 关系数据库管理系统执行CREATE VIEW语句的结果只是把视图的定义存入数据字典，并
不执行其中的SELECT语句。只是在对视图查询时，才按视图的定义从基本表中将
CREATE VIEW IS_S2
AS
SELECT Sno，Sname，Grade
FROM IS SI
WHERE Grade>=9;
-- 表中一般只存放数据,由基本数据计算派生出来的数据一般是不存储的,而视图中不存放
数据,所以一般用视图来定义派生列,这些列也称为虚拟列
DROP VIEW BT_S; -- 成功执行
DROP VIEW IS_S1; -- 拒绝执行
-- 执行此语句时由于IS_S1视图上还导出了IS_S2视图，所以该语句被拒绝执行。如果确
定要删除，则使用级联删除语句：
DROP VIEW IS S1 CASCADE; -- 删除了视图IS_S1和由它导出的所有视图
-- IS_Student视图
CREATE VIEW IS_Student
AS
SELECT Sno,Sname,Sage
FROM Student
WHERE Sdept='IS';
-- 在该视图上查询
SELECT Sno，Sage
FROM IS_Student
WHERE Sage<20;
-- 经过视图消解转换后的查询语句为
SELECT Sno,Sage
FROM Student
WHERE Sdept='IS' AND Sage<20;
视图消解实际上就是把视图的中定义的子查询查询出来的结果,再在查询视图的语句上根
据上面的结果写出视图消解的后的转换语句
5. 更新视图
视图IS_Student
1. 修改
[例3.95]将信息系学生视图IS_Student中学号为“201215122”的学生姓名改为“刘辰”。
2. 插入
[例3.96]向信息系学生视图IS_Student中插入一个新的学生记录，其中学号为
“201215129”，姓名为“赵新”，年龄为20岁。
3. 删除
[例3.97]删除信息系学生视图IS_Student中学号为“201215129”的记录。
6. 视图的作用
1. 视图能够简化用户的操作
2. 视图能使用户能以多种角度看待同一数据
3. 视图对重构数据库提供了一定程度的逻辑独立性
-- IS_Student视图
CREATE VIEW IS_Student
AS
SELECT Sno,Sname,Sage
FROM Student
WHERE Sdept='IS';
- UPDATE IS Student SET Sname='刘辰’
WHERE Sno='201215122';
-- 转换后的更新语句为
UPDATE Student
SET Sname='刘辰’
WHERE Sno='201215122' AND Sdept='IS';
INSERT
INTO IS_Student
VALUES('201215129','赵新',20);
-- 转换为对基本表的更新：
INSERT
INTO Student (Sno，Sname，Sage.Sdept)
VALUES('201215129','赵新',20,'IS');
-- 这里系统自动将系名IS放入VALUES子句中。
DELETE
FROM IS Student
WHERE Sno='201215129';
-- 转换为对基本表的更新;
DELETE
FROM Student
WHERE Sno='201215129' AND Sdept='IS';
4. 视图能够对机密数据提供安全保护
5. 适当利用视图可以更清晰地表达查询
6.
##第四章 数据库安全性
4.2 数据库安全性描述
1. 存储控制
1. 自主存储控制（Discretionary Access Control，DAC）
主要是通过SQL的GRANT语句和REVOKE语句来实现
1. 授权:GRANT
[例4.5]把对表SC的INSERT权限授予U5用户，并允许将此权限再授予其他用户。
[例4.6]
定义了WITH GRANT OPTION语句的用户可以授权给其他用户,但是不能循环授权,
也就是后面的授予前面的(这就类比类中的静态内容,静态的内容是不能访问非静态
内容的,因为静态内容先存在,非静态内容后存在,这里继承的用户的权限后存在,肯定
是从先存在的用户那里继承过来的权限,所以后面的授权用户不能反过来授予前面
的用户.)
2. 取消授权:REVOKE
[例4.10]把用户U5对SC表的INSERT权限收回。
2. 强制存储控制(p148)（Mandatory Access Control，MAC）
1. 在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。
1. 主体是系统中的活动实体，既包括数据库管理系统所管理的实际用户，也包括代表
用户的各进程。
2. 客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等
2. 强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可
分的整体，只有符合密级标记要求的用户才可以操纵数据，从而提供了更高级别的安全
性。
GRANT INSERT
ON TABLE SC
TO U5
WITH GRANT OPTION;
-- 执行此SQL语句后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限，即
由U5用户发上述GRANT命令给其他用户。例如U5可以将此权限授予U6（例4.6）。
GRANT INSERT
ON TABLE SC
TO U6
WITH GRANT OPTION;
-- 同样，U6还可以将此权限授予U7,以此类推....
REVOKE INSERT
ON TABLE SC
FROM U5 CASCADE;
-- 将用户U5的INSERT权限收回的同时，级联（CASCADE）收回了U6和U7的INSERT
权限，否则系统将拒绝执行该命令。
4.3 视图机制
1. 通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保
护。
2. 就是通过视图对不同的用户授予不同的权限
例题:用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，他不能
查看每个人的工资。
首先建立一个视图。然后对这个视图定义杨兰的存取权限。

##第五章 数据库完整性
5.1 实体完整性 主码
1. 关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。
2. 列级约束条件:定义在属性的后面
3. 表级约束条件:单独成一行,使用语句单独定义
5.2 参照完整性 外码
1. 关系模型的参照完整性在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码，用
REFERENCES短语指明这些外码参照哪些表的主码
[例5.3]定义SC中的参照完整性。
5.3 用户定义的完整性
1. 属性上的约束条件
列值非空（NOTNULL）。
列值唯一（UNIQUE）。
检查列值是否满足一个条件表达式（CHECK短语）。
CREATE VIEW 部门工资
AS
SELECT 部门.名称，MAX（工资）,MIN（工资）,AVG（工资）
FROM 职工，部门
WHERE 职工.部门号=部门.部门号
GROUP BY 职工.部门号;
GRANT SELECT ON TABLE 部门工资 TO 杨兰;
Sno CHAR(9) PRIMARY KEY
PRIMARY KEY(Sno)
CREATE TABLESC
(Sno CHAR（9）NOT NULL,
Cno CHAR（4）NOT NULL,
Grade SMALLINT,
PRIMARY KEY（Sno，Cno）,-- 在表级定义实体完整性
FOREIGN KEY（Sno）REFERENCES Student（Sno）,-- 在表级定义参照完整性
FOREIGN KEY（Cno）REFERENCES Course（Cno）-- 在表级定义参照完整性
)
2. 元组上的约束条件
[例5.9]当学生的性别是男时，其名字不能以Ms.打头。


##第六章 关系数据理论
6.1 问题的提出
1. 数据依赖是一个关系内部属性与属性之间的一种约束关系。
2. 第一范式(1FN):
一个二维表必须达到第一范式,也就是每一个分量(属性)是不可以分割的
3. 函数依赖:
Sname=f(Sno)，即Sno函数决定Sname，S或者说Sname函数依赖于Sno，记作Sno->Sname，
4. 什么是一个好的关系模式?
一个好的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。
6.2 规范化
1. 函数依赖
1. 完全函数依赖
在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性
的话），X ' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖,用F表示
(学号,课名)--> 分数
学号和课名同时才能决定分数,他们两个之间的任何一个都不行
2. 部分函数依赖
Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X,
用P表示
(学号,课号)-->姓名
学号就可以决定姓名
3. 传递函数依赖
Z 函数依赖于 Y，且 Y 函数依赖于 X ,Y 不包含于 X，且 X 不函数依赖于 Y(如果这样,就会
变成直接传递依赖),就称 Z 传递函数依赖于 X,用T表示
Sno-->Sdept, Sdept-->Mname, 则有: Sno-->Mname
2. 码
1. 候选码:某一个属性组的值能够唯一的标识一个元组,而其子集不能,则称该属性组为候选码
2. 主码:若一个关系中有多个候选码,则选定其中的一个为主码
3. 主属性:候选码属性组中的各个属性称为主属性
CREATE TABLE Student
(Sno CHAR（9）,
Sname CHAR（8）NOT NULL,
Ssex CHAR（2）,
Sage SMALLINT,
Sdept CHAR（20）,
PRIMARY KEY（Sno）,
CHECK（Ssex='女'OR Sname NOT LIKE'Ms.%'）
);
-- 定义了元组中Sname和Ssex两个属性值之间的约束条件
4. 非主属性:不包含在候选码中的属性称为非主属性
5. 全码:关系模式的所有属性是这个关系的候选码,则称该属性组为全码
例子:关系模式学生信息(学号、姓名、性别、系别、身份证号码)
候选码:学号,身份证号码
主码:学号或身份证号码
主属性:学号和身份证号码
非主属性:姓名、性别、系别
注意:这里的候选码不能为(学号,身份证号码),因为其不符合候选码的定义,但是它是一个
超码.
学号可以唯一的标识出一个同学的身份，我们可以设置学号为主码。是最简单的候选
码。
注意:主属性不能唯一的标识一个元组,而主码必定能够标识(因为主码必定是候选码),两
者是不同的.
3. 范式NF(Normal Form)
1. 关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。
2. 一个低一级范式的关系模式通过模式分解（schema decomposition）可以转换为若干个高
一级范式的关系模式的集合，这种过程就叫规范化（normalization）。
3. 1NF:符合1NF的关系中的每个属性都不可再分,1NF是所有关系型数据库的最基本要求。
4. 2NF
2NF在1NF的基础之上，消除了非主属性对于候选码的部分函数依赖。
5. 3FN
在2NF的基础之上，消除了非主属性对于候选码的传递函数依赖。
6. BCNF
在 3NF 的基础上消除主属性对于候选码的部分与传递函数依赖。
判断是第几范式的方法:
1. 找出数据表中所有的候选码。
2. 根据第一步所得到的码，找出所有的主属性。
3. 数据表中，除去所有的主属性，剩下的就都是非主属性了。
4. 查看是否存在属性对候选码的部分函数依赖或者传递函数依赖。
1. 非主属性不存在对候选码的部分函数依赖,2NF
2. 非主属性不存在对候选码的部分函数依赖和传递函数依赖,3NF
3. 在第三范式的基础上,主属性存在对候选码的传递函数依赖与部分函数依赖,BCNF
对于第一步:
1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确
定。
3. 依次类推.....
技巧:如果某属性或属性组A确定为候选码,那么包含了A的属性组,如:(A,B),(A,C),
(A,B,C)等等,都不是候选码了,因为候选码的子集必须不能唯一确定一个元组,候选码
中不能有候选码,这样也矛盾了,这里的(A,B),(A,C),(A,B,C)是超码
例题:
学生表(学号,姓名,系名,系主任,课名分数)
1. 候选码:(学号,课名)
2. 主属性:学号,课名
3. 非主属性:姓名,系名,系主任,分数
4. 依赖关系:
1. 对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码
（学号，课名）的部分函数依赖。
2. 对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码
（学号，课名）的部分函数依赖。
3. 对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 对码
（学号，课名）的部分函数依赖。
5. 所以存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要
求。
6. 进行模式分解后有关系模式:
选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）
对于选课表:
候选码:(学号,课名)
主属性:学号,课名
非主属性:分数
依赖关系:学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所
以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合
2NF的要求。
对于学生表:
候选码:学号
主属性:学号
非主属性:姓名、系名和系主任
依赖关系:
因为码只有一个属性，所以不可能存在非主属性对于码的部分函数依赖，所
以此表符合2NF的要求。
对于该表判断是否符合第三范式的要求
对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，
为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。
对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为
学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递
函数依赖，所以学生表的设计，不符合3NF的要求。
7. 进一步进行模式分解
选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）
对于选课表，符合3NF的要求，之前已经分析过了。
对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码
的传递函数依赖，所以符合3NF的要求。
对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码
的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的
要求。
某公司有若干个仓库；
1. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
2. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个
仓库中都有对应的数量。
那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？
1. 码：（管理员，物品名），（仓库名，物品名）
2. 主属性：仓库名、管理员、物品名
3. 非主属性：数量
4. 已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。
造成此问题的原因：存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是
存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。
进行模式分解()后:
在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。
仓库（仓库名，管理员）
库存（仓库名，物品名，数量）
这就是BCNF范式.
7. 规范化小结
基本思想:逐步消除数据依赖中不适合的部分
模式设计原则:"一事一地"
规范化的实质:概念的单一化
关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若
干个高一级的关系模式


##第七章 数据库的设计
7.1 数据库设计概述
1. 数据库设计
广义的讲:是数据库及其应用系统的设计，即设计整个数据库应用系统；
狭义的讲:是设计数据库本身，即设计数据库的各级模式并建立数据库;
2. 数据库设计的基本步骤
1. 需求分析；
2. 概念结构设计；
3. 逻辑结构设计；
4. 物理结构设计；
5. 数据库实施；
6. 数据库运行和维护。
3. 数据库的各级模式
1. 概念模式:视图
2. 逻辑模式:基本表
3. 内模式:物理结构
7.2 需求分析
1. 数据词典
内容:数据字典的内容通常包括数据项、数据结构、数据流、数据存储和处理过程5个部分
作用:数据字典是关于数据库中数据的描述，在需求分析阶段建立，是下一步进行概念设计的
基础，并在数据库设计过程中不断修改、充实和完善。
7.3 概念结构设计
1. E-R图的集成
1. 步骤
1. 合并(消除冲突)
2. 修改和重构(消除不必要的冗余)
2. E-R图之间的冲突
1. 属性冲突
2. 命名冲突
3. 结构冲突
在初步E-R图中可能存在一些冗余的数据和实体间冗余的联系。所谓冗余的数据是指可由基本
数据导出的数据，冗余的联系是指可由其他联系导出的联系。冗余数据和冗余联系容易破坏
数据库的完整性，给数据库维护增加困难，应当予以消除。消除了冗余后的初步E-R图称为基
本E-R图。
7.4 逻辑结构设计
1. 数据模型的优化
1. 数据库逻辑设计不是唯一的
2. 并不是规范化程度越高的关系就越优
3. 模式分解
1. 水平分解:水平分解是把（基本）关系的元组分为若干子集合，定义每个子集合为一个子
关系，以提高系统的效率。根据“80/20原则”.
2. 垂直分解:垂直分解是把关系模式R的属性分解为若干子集合，形成若干子关系模式。
7.5 物理结构设计
1. 设计步骤
1. 确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构
2. 对物理结构进行评价，评价的重点是时间和空间效率。
2. 设计的内容:为关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。
7.6 数据库的实施和维护
1. 数据库应用程序的设计应该与数据库设计同时进行
2. 数据库的试运行
1. 应分期分批地组织数据入库，先输入小批量数据做调试用，待试运行基本合格后再大批量输
入数据，逐步增加数据量，逐步完成运行评价。
2. 要做好数据库的转储和恢复工作。一旦故障发生，能使数据库尽快恢复，尽量减少对数据库
的破坏。

##第十章 数据库恢复技术
10.1 事务的基本概念
1. 所谓事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一不可分割的工
作单位。
2. 定义事务的语句:
1. BEGIN TRANSACTION;
开启事务
2. COMMIT;
提交事务;提交事务的所有操作
3. ROLLBACK;
回滚事务:系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状
态。
3. 事务的ACID特性(ACID properties)(理解p294)
1. 原子性(Atomicity)
2. 一致性(Consistency)
3. 隔离性(Isolation)
4. 持续性(Durability)
10.3 故障的种类
1. 事务内部的故障
2. 系统故障
3. 介质故障
4. 计算机病毒
10.4 恢复的实现技术
1. 数据转存
方法
1. 动态海量转储
2. 动态增量转储
3. 静态海量转储
4. 静态增量转储
2. 登记日志文件
1. 内容:日志文件是用来记录事务对数据库更新操作的文件
2. 日志文件的作用
（1）事务故障恢复和系统故障恢复必须用日志文件。
（2）在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地
恢复数据库。
（3）在静态转储方式中也可以建立日志文件，当数据库毁坏后可重新装入后援副本把
数据库恢复到转储结束时刻的正确状态，然后利用日志文件把已完成的事务进行重做处
理，对故障发生时尚未完成的事务进行撤销处理。这样不必重新运行那些已完成的事务
程序就可把数据库恢复到故障前某一时刻的正确状态.。
3. 登录日志文件必须遵守的两条规则
1. 登记的次序严格按并发事务执行的时间次序。
2. 必须先写日志文件，后写数据库。


##第十一章 并发控制
11.1 并发控制概述
1. 事务是并发控制的基本单位,并发控制可以保证事务的一致性和隔离性
2. 并发控制带来的数据不一致性包括:
1. 丢失修改
2. 不可重复读
3. 读脏数据
11.2 封锁
1. 封锁是实现并发控制的一个非常重要的技术
2. 概念:封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。
加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新或
读取此数据对象。
3. 基本的封锁类型
1. 排他锁(exclusive locks),简称X锁,又称写锁
2. 共享锁(share locks),简称S锁,又称读锁
11.4 活锁和死锁
类比操作系统中的活锁和死锁的问题...
1. 活锁:
1. 定义:一个事务等待时间太长，似乎被锁住了，实际上可能被激活。
2. 解决办法:先来先服务的策略,类比操作系统的FCFS调度算法...
2. 死锁
1. 定义:简而言之就是,多个事物之间互相请求对方的资源而等待,导致永不结束
2. 死锁的诊断与解除
1. 与操作系统类似，一般使用超时法或事务等待图法。
2. DBMS并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是选择一个处理
死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行
下去。

11.6 两段锁协议
所谓两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。

在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；
在释放一个封锁之后，事务不再申请和获得任何其他封锁。
“两段”锁的含义是事务分为两个阶段:

第一阶段是获得封锁，也称为扩展阶段，在这个阶段，事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁；
第二阶段是释放封锁，也称为收缩阶段，在这个阶段，事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。
例如，事务T，遵守两段锁协议，其封锁序列是
Slock A Slock B Xlock C Unlock B Unlock A Unlock C；
|<一 扩展阶段 一 > | |<一 收缩阶段 一>|
又如，事务T，不遵守两段锁协议，其封锁序列是
Slock A UnlockA Slock B Xlock C Unlock C UnlockB；
11.7 封锁的粒度
概念:封锁的大小称为封锁的粒度
